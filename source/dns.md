---
title: DNS
---
# DNS

## DNS协议：网络世界的地址簿
### DNS 服务器
网络世界是很难记住网站的 IP 地址，于是，就需要一个地址簿，根据名称，就可以查看具体的地址，就是**DNS 服务器**。

DNS 在日常生活中非常重要。每个人上网，都需要访问它。一旦它出了故障，整个互联网都将瘫痪。另外，上网的人分布在全世界各地，如果大家都去同一个地方访问某一台服务器，时延将会非常大。因而，**DNS 服务器，
一定要设置成高可用、高并发和分布式的**。

![](/images/network-protocol/dnsarch.jpg)

- 根DNS 服务器：返回顶级域DNS 服务器的IP 地址
- 顶级域DNS 服务器：返回权威DNS 服务器的IP 地址
- 权威DNS 服务器：返回相应主机的IP 地址

### DNS 解析流程
为了提高DNS 的解析性能，很多网络都会就近部署DNS 缓存服务器。于是，就有了以下的DNS 解析流程。

1. 电脑客户端会发出一个DNS 请求，问`www.163.com`的IP 是啥啊，并发给本地域名服务器(本地DNS)。那本地域名服务器(本地DNS) 是什么呢？如果是通过DHCP 配置，本地DNS 由你的网络服务商（ISP），如电信、
移动等自动分配，它通常就在你网络服务商的某个机房。
2. 本地DNS 收到来自客户端的请求。你可以想象这台服务器上缓存了一张域名与之对应IP 地址的大表格。如果能找到`www.163.com`，它直接就返回IP 地址。如果没有，本地DNS 会去问它的根域名服务器：“老大，
能告诉我`www.163.com`的IP 地址吗？”根域名服务器是最高层次的，全球共有13 套。它不直接用于域名解析，但能指明一条道路。
3. 根DNS 收到来自本地DNS 的请求，发现后缀是`.com`，说：“哦，`www.163.com`啊，这个域名是由`.com`区域管理，我给你它的顶级域名服务器的地址，你去问问它吧。
4. 本地DNS 转向问顶级域名服务器：“老二，你能告诉我`www.163.com`的IP 地址吗？”顶级域名服务器就是大名鼎鼎的比如`.com`、`.net`、`.org`这些一级域名，它负责管理二级域名，
比如`163.com`，所以它能提供一条更清晰的方向。
5. 顶级域名服务器说：“我给你负责`www.163.com`区域的权威DNS 服务器的地址，你去问它应该能问到。”
6. 本地DNS 转向问权威DNS 服务器：“您好，`www.163.com`对应的IP 是啥呀？”`163.com`的权威DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。
7. 权威DNS 服务器查询后将对应的IP 地址`X.X.X.X`告诉本地DNS。
8. 本地DNS 再将IP 地址返回客户端，客户端和目标建立连接。

![](/images/network-protocol/dnsparse.jpg)

### 负载均衡
站在客户端角度，这是一次**DNS 递归查询过程**。因为本地DNS 全权为它效劳，它只要坐等结果即可。在这个过程中，DNS 除了可以通过名称映射为IP 地址，它还可以做另外一件事，就是**负载均衡**。

以访问“外婆家”为例，它可能有很多地址，因为它在杭州可以有很多家。所以，如果一个人想去吃“外婆家”，他可以就近找一家店，而不用大家都去同一家，这就是负载均衡。

DNS 首先可以做**内部负载均衡**。

例如，应用要访问数据库，配置这个数据库的域名，这样数据库如果IP地址修改，就不需要一个个修改应用的配置，直接修改DNS配置。
例如，当某个被访问的应用撑不住的时候，可以部署多个，只要配置域名，在域名解析的时候，我们只要配置策略，这次返回第一个IP，下次返回第二个IP，就可以实现负载均衡了。

DNS 还可以做**全局负载均衡**。

例如，我们肯定希望北京的用户访问北京的数据中心，上海的用户访问上海的数据中心，这样，客户体验就会非常好，访问速度就会超快。这就是全局负载均衡的概念。


### DNS 访问数据中心中对象存储上的静态资源

假设全国有多个数据中心，托管在多个运营商，每个数据中心三个可用区（Available Zone）。对象存储通过跨可用区部署，实现高可用性。在每个数据中心中，都至少部署两个内部负载均衡器，内
部负载均衡器后面对接多个对象存储的前置服务器（Proxy-server）。

![](/images/network-protocol/dnslb.jpg)

1. 当一个客户端要访问`object.yourcompany.com`的时候，需要将域名转换为IP 地址进行访问，所以它要请求本地DNS 解析器。
2. 本地DNS 解析器先查看看本地的缓存是否有这个记录。如果有则直接使用，因为上面的过程太复杂了，如果每次都要递归解析，就太麻烦了。
3. 如果本地无缓存，则需要请求本地的DNS 服务器。
4. 本地的DNS 服务器一般部署在你的数据中心或者你所在的运营商的网络中，本地DNS 服务器也需要看本地是否有缓存，如果有则返回，因为它也不想把上面的递归过程再走一遍。
5. 如果本地没有，本地DNS 才需要递归地从根DNS 服务器，查到`.com`的顶级域名服务器，最终查到`yourcompany.com`的权威DNS 服务器，给本地DNS 服务器，权威DNS 服务器按说会返回真实要访问的IP 地址。

对于不需要做全局负载均衡的简单应用来讲，`yourcompany.com`的权威DNS 服务器可以直接将`object.yourcompany.com`这个域名解析为一个或者多个IP 地址，然后客户端可以通过多个IP 地址，
进行简单的轮询，实现简单的负载均衡。

但是对于复杂的应用，尤其是跨地域跨运营商的大型应用，则需要更加复杂的全局负载均衡机制，因而需要专门的设备或者服务器来做这件事情，这就是**全局负载均衡器（GSLB，Global Server LoadBalance）**。

在yourcompany.com 的DNS 服务器中，一般是通过**配置CNAME 的方式**，给`object.yourcompany.com`起一个别名，例如object.vip.yourcomany.com，然后告诉本地DNS 服务器，让它请求GSLB 解析这个域名，
GSLB 就可以在解析这个域名的过程中，通过自己的策略实现负载均衡。

图中画了两层的GSLB，是因为分运营商和地域。我们希望不同运营商的客户，可以访问相同运营商机房中的资源，这样不跨运营商访问，有利于提高吞吐量，减少时延.

1. 第一层GSLB，通过查看请求它的本地DNS 服务器所在的运营商，就知道用户所在的运营商。假设是移动，通过CNAME 的方式，通过另一个别名`object.yd.yourcompany.com`，告诉本地DNS 服务器去请求第二层的GSLB。
2. 第二层GSLB，通过查看请求它的本地DNS 服务器所在的地址，就知道用户所在的地理位置，然后将距离用户位置比较近的Region 里面，六个**内部负载均衡（SLB，Server Load Balancer）**的地址，返回给本地DNS 服务器。
3. 本地DNS 服务器将结果返回给本地DNS 解析器。
4. 本地DNS 解析器将结果缓存后，返回给客户端。
5. 客户端开始访问属于相同运营商的距离较近的Region 1 中的对象存储，当然客户端得到了六个IP地址，它可以通过负载均衡的方式，随机或者轮询选择一个可用区进行访问。对象存储一般会有三个备份，
从而可以实现对存储读写的负载均衡。

## HTTPDNS：网络世界的地址簿也会指错路

有时候这个地址簿也经常给你指错路，明明距离你500 米就有个吃饭的地方，非要把你推荐到5 公里外。为什么会出现这样的情况呢？

当我们发出请求解析DNS 的时候，首先，会先连接到运营商本地的DNS 服务器，由这个服务器帮我们去整棵DNS 树上进行解析，然后将解析的结果返回给客户端。但是本地的DNS 服务器，
作为一个本地导游，往往有自己的“小心思”。

### 传统DNS 存在哪些问题？
#### 域名缓存问题
它可以在本地做一个缓存，也就是说，不是每一个请求，它都会去访问权威DNS 服务器，而是访问过一次就把结果缓存到自己本地，当其他人来问的时候，直接就返回这个缓存数据。

这就相当于导游去过一个饭店，自己脑子记住了地址，当有一个游客问的时候，他就凭记忆回答了，不用再去查地址簿。这样经常存在的一个问题是，人家那个饭店明明都已经搬了，结果作为导游，
他并没有刷新这个缓存，结果你辛辛苦苦到了这个地点，发现饭店已经变成了服装店，你是不是会非常失望？

另外，有的运营商会把一些静态页面，缓存到本运营商的服务器内，这样用户请求的时候，就不用跨运营商进行访问，这样既加快了速度，也减少了运营商之间流量计算的成本。在域名解析的时候，
不会将用户导向真正的网站，而是指向这个缓存的服务器。

很多情况下是看不出问题的，但是当页面更新，用户会访问到老的页面，问题就出来了。例如，你听说一个餐馆推出了一个新菜，你想去尝一下。结果导游告诉你，在这里吃也是一样的。有的游客会觉得没问题，
但是对于想尝试新菜的人来说，如果导游说带你去，但其实并没有吃到新菜，你是不是也会非常失望呢？

再就是本地的缓存，往往使得全局负载均衡失败，因为上次进行缓存的时候，缓存中的地址不一定是这次访问离客户最近的地方，如果把这个地址返回给客户，那肯定就会绕远路。

就像客户要吃西湖醋鱼，导游知道西湖边有一家，因为当时游客就在西湖边，可是，下一次客户在灵隐寺，想吃西湖醋鱼的时候，导游还指向西湖边的那一家，那这就绕的太远了。

#### 域名转发问题

这样的问题是，如果是A 运营商的客户，访问自己运营商的DNS 服务器，如果A 运营商去权威DNS服务器查询的话，权威DNS 服务器知道你是A 运营商的，就返回给一个部署在A 运营商的网站地址，
这样针对相同运营商的访问，速度就会快很多。

但是A 运营商偷懒，将解析的请求转发给B 运营商，B 运营商去权威DNS 服务器查询的话，权威服务器会误认为，你是B 运营商的，那就返回给你一个在B 运营商的网站地址吧，结果客户的每次访问都要
跨运营商，速度就会很慢。

#### 出口NAT 问题

很多机房都会配置NAT，也即网络地址转换，使得从这个网关出去的包，都换成新的IP 地址，当然请求返回的时候，在这个网关，再将IP 地址转换回去，所以对于访问来说是没有任何问题。

但是一旦做了网络地址的转换，权威的DNS 服务器，就没办法通过这个地址，来判断客户到底是来自哪个运营商，而且极有可能因为转换过后的地址，误判运营商，导致跨运营商的访问。

#### 域名更新问题

本地DNS 服务器是由不同地区、不同运营商独立部署的。对域名解析缓存的处理上，实现策略也有区别，有的会偷懒，忽略域名解析结果的TTL 时间限制，在权威DNS 服务器解析变更的时候，
解析结果在全网生效的周期非常漫长。但是有的时候，在DNS 的切换中，场景对生效时间要求比较高。

例如双机房部署的时候，跨机房的负载均衡和容灾多使用DNS 来做。当一个机房出问题之后，需要修改权威DNS，将域名指向新的IP 地址，但是如果更新太慢，那很多用户都会出现访问异常。

#### 解析延迟问题

DNS 的查询过程需要递归遍历多个DNS 服务器，才能获得最终的解析结果，这会带来一定的时延，甚至会解析超时。

### HTTPDNS 的工作模式

**HTTPNDS 其实就是，不走传统的DNS 解析，而是自己搭建基于HTTP 协议的DNS 服务器集群，分布在多个地点和多个运营商。当客户端需要DNS 解析的时候，直接通过HTTP 协议进行请求这个
服务器集群，得到就近的地址**。

这就相当于每家基于HTTP 协议，自己实现自己的域名解析，自己做一个自己的地址簿，而不使用统一的地址簿。但是默认的域名解析都是走DNS 的，因而使用HTTPDNS 需要绕过默认的DNS 路径，就不能使用默认
的客户端。使用HTTPDNS 的，往往是手机应用，需要在手机端嵌入支持HTTPDNS 的客户端SDK。

#### 解析 HTTPDNS 的工作模式。

在客户端的SDK 里动态请求服务端，获取HTTPDNS 服务器的IP 列表，缓存到本地。随着不断地解析域名，SDK 也会在本地缓存DNS 域名解析的结果。

当手机应用要访问一个地址的时候，首先看是否有本地的缓存，如果有就直接返回。这个缓存和本地DNS 的缓存不一样的是，这个是手机应用自己做的，而非整个运营商统一做的。如何更新、何时更新，
手机应用的客户端可以和服务器协调来做这件事情。

如果本地没有，就需要请求HTTPDNS 的服务器，在本地HTTPDNS 服务器的IP 列表中，选择一个发出HTTP 的请求，会返回一个要访问的网站的IP 列表。

当所有这些都不工作的时候，可以切换到传统的LocalDNS 来解析。

#### HTTPDNS 的缓存设计
解析DNS 过程复杂，通信次数多，对解析速度造成很大影响。为了加快解析，因而有了缓存，但是这又会产生缓存更新速度不及时的问题。最要命的是，这两个方面都掌握在别人手中，也即本地DNS 服务器手
中，它不会为你定制，你作为客户端干着急没办法。

而HTTPDNS 就是将解析速度和更新速度全部掌控在自己手中。一方面，解析的过程，不需要本地DNS服务递归的调用一大圈，一个HTTP 的请求直接搞定，要实时更新的时候，马上就能起作用；另一方面为了
提高解析速度，本地也有缓存，缓存是在客户端SDK 维护的，过期时间、更新时间，都可以自己控制。

HTTPDNS 的缓存设计策略也是咱们做应用架构中常用的缓存设计模式，也即分为客户端、缓存、数据源三层。

只要是缓存模式，就存在缓存的过期、更新、不一致的问题，解决思路也是很像的。

例如DNS 缓存在内存中，也可以持久化到存储上，从而APP 重启之后，能够尽快从存储中加载上次累积的经常访问的网站的解析结果，就不需要每次都全部解析一遍，再变成缓存。这有点像Redis 是基于内存的缓存，
但是同样提供持久化的能力，使得重启或者主备切换的时候，数据不会完全丢失。

SDK 中的缓存会严格按照缓存过期时间，如果缓存没有命中，或者已经过期，而且客户端不允许使用过期的记录，则会发起一次解析，保障记录是更新的。

解析可以**同步进行**，也就是直接调用HTTPDNS 的接口，返回最新的记录，更新缓存；也可以**异步进行**，添加一个解析任务到后台，由后台任务调用HTTPDNS 的接口。


#### HTTPDNS 的调度设计

由于客户端嵌入了SDK，因而就不会因为本地DNS 的各种缓存、转发、NAT，让权威DNS 服务器误会客户端所在的位置和运营商，而可以拿到第一手资料。

在客户端，可以知道手机是哪个国家、哪个运营商、哪个省，甚至哪个市，HTTPDNS 服务端可以根据这些信息，选择最佳的服务节点返回。

在服务端，应用可以通过调用HTTPDNS 的管理接口，配置不同服务质量的优先级、权重。HTTPDNS会根据这些策略综合地理位置和线路状况算出一个排序，优先访问当前那些优质的、时延低的IP 地址。


DNS （Domain Name System ）的作用非常简单，就是根据域名查出IP地址。你可以把它想象成一本巨大的电话本。
举例来说，如果你要访问域名`math.stackexchange.com`，首先要通过DNS查出它的IP地址是`151.101.129.69`。

<!-- more -->

## 查询过程
虽然只需要返回一个IP地址，但是DNS的查询过程非常复杂，分成多个步骤。
工具软件`dig`可以显示整个查询过程。
``` bash
$ dig math.stackexchange.com
```
上面的命令会输出六段信息。

![](/images/DNS-introduction/1.png)

第一段是查询参数和统计。

![](/images/DNS-introduction/2.png)

第二段是查询内容。

![](/images/DNS-introduction/3.png)

上面结果表示，查询域名`math.stackexchange.com`的`A`记录，`A`是`address`的缩写。
第三段是DNS服务器的答复。

![](/images/DNS-introduction/4.png)

上面结果显示，`math.stackexchange.com`有四个`A`记录，即四个IP地址。600是TTL值（Time to live 的缩写），表示缓存时间，即600秒之内不用重新查询。
第四段显示`stackexchange.com`的`NS`记录（Name Server的缩写），即哪些服务器负责管理`stackexchange.com`的DNS记录。

![](/images/DNS-introduction/5.png)

上面结果显示`stackexchange.com`共有四条NS记录，即四个域名服务器，向其中任一台查询就能知道`math.stackexchange.com`的IP地址是什么。
第五段是上面四个域名服务器的IP地址，这是随着前一段一起返回的。

![](/images/DNS-introduction/6.png)

第六段是DNS服务器的一些传输信息。

![](/images/DNS-introduction/7.png)

上面结果显示，本机的DNS服务器是`192.168.1.253`，查询端口是53（DNS服务器的默认端口），以及回应长度是305字节。
如果不想看到这么多内容，可以使用`+short`参数。

``` bash
$ dig +short math.stackexchange.com

151.101.129.69
151.101.65.69
151.101.193.69
151.101.1.69
```
上面命令只返回`math.stackexchange.com`对应的4个IP地址（即`A`记录）。

## DNS服务器
下面我们根据前面这个例子，一步步还原，本机到底怎么得到域名`math.stackexchange.com`的IP地址。
首先，本机一定要知道DNS服务器的IP地址，否则上不了网。通过DNS服务器，才能知道某个域名的IP地址到底是什么。

![](/images/DNS-introduction/8.jpg)

DNS服务器的IP地址，有可能是动态的，每次上网时由网关分配，这叫做DHCP机制；也有可能是事先指定的固定地址。Linux系统里面，DNS服务器的IP地址保存在`/etc/resolv.conf`文件。
上例的DNS服务器是`192.168.1.253`，这是一个内网地址。有一些公网的DNS服务器，也可以使用，其中最有名的就是Google的`8.8.8.8`和Level 3的`4.2.2.2`。
本机只向自己的DNS服务器查询，`dig`命令有一个`@`参数，显示向其他DNS服务器查询的结果。
``` bash
$ dig @4.2.2.2 math.stackexchange.com
```
上面命令指定向DNS服务器`4.2.2.2`查询。

## 域名的层级
DNS服务器怎么会知道每个域名的IP地址呢？答案是分级查询。
请仔细看前面的例子，每个域名的尾部都多了一个点。

![](/images/DNS-introduction/9.png)

比如，域名`math.stackexchange.com`显示为`math.stackexchange.com.`。这不是疏忽，而是所有域名的尾部，实际上都有一个根域名。
举例来说，`www.example.com`真正的域名是`www.example.com.root`，简写为`www.example.com.`。因为，根域名`.root`对于所有域名都是一样的，所以平时是省略的。
根域名的下一级，叫做"顶级域名"（top-level domain，缩写为TLD），比如`.com`、`.net`；再下一级叫做"次级域名"（second-level domain，缩写为SLD），比如`www.example.com`里面的`.example`，这一级域名是用户可以注册的；再下一级是主机名（host），比如`www.example.com`里面的`www`，又称为"三级域名"，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。
总结一下，域名的层级结构如下。

``` bash
主机名.次级域名.顶级域名.根域名

# 即

host.sld.tld.root
```
## 根域名服务器
DNS服务器根据域名的层级，进行分级查询。
需要明确的是，每一级域名都有自己的NS记录，NS记录指向该级域名的域名服务器。这些服务器知道下一级域名的各种记录。
所谓"分级查询"，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址，过程大致如下。

1. 从"根域名服务器"查到"顶级域名服务器"的NS记录和A记录（IP地址）
2. 从"顶级域名服务器"查到"次级域名服务器"的NS记录和A记录（IP地址）
3. 从"次级域名服务器"查出"主机名"的IP地址

仔细看上面的过程，你可能发现了，没有提到DNS服务器怎么知道"根域名服务器"的IP地址。回答是"根域名服务器"的NS记录和IP地址一般是不会变化的，所以内置在DNS服务器里面。
下面是内置的根域名服务器IP地址的一个例子。

![](/images/DNS-introduction/10.png)

上面列表中，列出了根域名（`.root`）的三条NS记录`A.ROOT-SERVERS.NET`、`B.ROOT-SERVERS.NET`和`C.ROOT-SERVERS.NET`，以及它们的IP地址（即A记录）`198.41.0.4`、`192.228.79.201`、`192.33.4.12`。
另外，可以看到所有记录的TTL值是3600000秒，相当于1000小时。也就是说，每1000小时才查询一次根域名服务器的列表。
目前，世界上一共有十三组根域名服务器，从`A.ROOT-SERVERS.NET`一直到`M.ROOT-SERVERS.NET`。
## 分级查询的实例
`dig`命令的`+trace`参数可以显示DNS的整个分级查询过程。
``` bash
$ dig +trace math.stackexchange.com
```
上面命令的第一段列出根域名`.`的所有NS记录，即所有根域名服务器。

![](/images/DNS-introduction/11.png)

根据内置的根域名服务器IP地址，DNS服务器向所有这些IP地址发出查询请求，询问`math.stackexchange.com`的顶级域名服务器`com.`的NS记录。最先回复的根域名服务器将被缓存，以后只向这台服务器发请求。
接着是第二段。

![](/images/DNS-introduction/12.png)

上面结果显示`.com`域名的13条NS记录，同时返回的还有每一条记录对应的IP地址。
然后，DNS服务器向这些顶级域名服务器发出查询请求，询问`math.stackexchange.com`的次级域名`stackexchange.com`的NS记录。

![](/images/DNS-introduction/13.png)

上面结果显示`stackexchange.com`有四条NS记录，同时返回的还有每一条NS记录对应的IP地址。
然后，DNS服务器向上面这四台NS服务器查询`math.stackexchange.com`的主机名。

![](/images/DNS-introduction/14.png)

上面结果显示，`math.stackexchange.com`有4条`A`记录，即这四个IP地址都可以访问到网站。并且还显示，最先返回结果的NS服务器是`ns-463.awsdns-57.com`，IP地址为`205.251.193.207`。
## NS 记录的查询
`dig`命令可以单独查看每一级域名的NS记录。
``` bash
$ dig ns com
$ dig ns stackexchange.com
```
`+short`参数可以显示简化的结果。
```bash
$ dig +short ns com
$ dig +short ns stackexchange.com
```
## DNS的记录类型
域名与IP之间的对应关系，称为"记录"（record）。根据使用场景，"记录"可以分成不同的类型（type），前面已经看到了有`A`记录和`NS`记录。
常见的DNS记录类型如下。

1. A记录：将域名指向一个IPv4地址（例如：100.100.100.100），需要增加A记录
2. CNAME记录：如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。这个域名一般是主机服务商提供的一个域名
3. MX记录：建立电子邮箱服务，将指向邮件服务器地址，需要设置MX记录。建立邮箱时，一般会根据邮箱服务商提供的MX记录填写此记录
4. NS记录：域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置NS记录
5. TXT记录：可任意填写，可为空。一般做一些验证记录时会使用此项，如：做SPF（反垃圾邮件）记录
6. AAAA记录：将主机名（或域名）指向一个IPv6地址（例如：ff03:0:0:0:0:0:0:c1），需要添加AAAA记录
7. SRV记录：添加服务记录服务器服务记录时会添加此项，SRV记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）。
8. SOA记录：SOA叫做起始授权机构记录，NS用于标识多台域名解析服务器，SOA记录用于在众多NS记录中那一台是主服务器
9. PTR记录：PTR记录是A记录的逆向记录，又称做IP反查记录或指针记录，负责将IP反向解析为域名
10. 显性URL转发记录：将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址。例如：将www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址为：www.itbilu.com。
11. 隐性UR转发记录L：将域名指向一个http(s)协议地址，访问域名时，自动跳转至目标地址，隐性转发会隐藏真实的目标地址。例如：将www.liuht.cn显性转发到www.itbilu.com后，访问www.liuht.cn时，地址栏显示的地址仍然是：www.liuht.cn。


一般来说，为了服务的安全可靠，至少应该有两条`NS`记录，而`A`记录和`MX`记录也可以有多条，这样就提供了服务的冗余性，防止出现单点失败。
`CNAME`记录主要用于域名的内部跳转，为服务器配置提供灵活性，用户感知不到。举例来说，`facebook.github.io`这个域名就是一个`CNAME`记录。
``` bash
$ dig facebook.github.io

...

;; ANSWER SECTION:
facebook.github.io. 3370    IN  CNAME   github.map.fastly.net.
github.map.fastly.net.  600 IN  A   103.245.222.133
```
上面结果显示，`facebook.github.io`的`CNAME`记录指向`github.map.fastly.net`。也就是说，用户查询`facebook.github.io`的时候，实际上返回的是`github.map.fastly.net`的IP地址。这样的好处是，变更服务器IP地址的时候，只要修改`github.map.fastly.net`这个域名就可以了，用户的`facebook.github.io`域名不用修改。
由于CNAME记录就是一个替换，所以域名一旦设置`CNAME`记录以后，就不能再设置其他记录了（比如`A`记录和`MX`记录），这是为了防止产生冲突。举例来说，`foo.com`指向`bar.com`，而两个域名各有自己的`MX`记录，如果两者不一致，就会产生问题。由于顶级域名通常要设置MX记录，所以一般不允许用户对顶级域名设置`CNAME`记录。
`PTR`记录用于从IP地址反查域名。`dig`命令的`-x`参数用于查询PTR记录。
``` bash
$ dig -x 192.30.252.153

...

;; ANSWER SECTION:
153.252.30.192.in-addr.arpa. 3600 IN    PTR pages.github.com.
```
上面结果显示，`192.30.252.153`这台服务器的域名是`pages.github.com`。
逆向查询的一个应用，是可以防止垃圾邮件，即验证发送邮件的IP地址，是否真的有它所声称的域名。
`dig`命令可以查看指定的记录类型。
``` bash
$ dig a github.com
$ dig ns github.com
$ dig mx github.com
```
## 常见问题
DNS解析中一些问题

### A记录与CNAME记录
`A`记录是把一个域名解析到一个IP地址，而`CNAME`记录是把域名解析到另外一个域名，而这个域名最终会指向一个`A`记录，在功能实现在上`A`记录与`CNAME`记录没有区别。
`CNAME`记录在做IP地址变更时要比`A`记录方便。`CNAME`记录允许将多个名字映射到同一台计算机，当有多个域名需要指向同一服务器IP，此时可以将一个域名做`A`记录指向服务器IP，然后将其他的域名做别名(即：`CNAME`)到`A`记录的域名上。当服务器IP地址变更时，只需要更改`A`记录的那个域名到新IP上，其它做别名的域名会自动更改到新的IP地址上，而不必对每个域名做更改。

### A记录与AAAA记录
二者都是指向一个IP地址，但对应的IP版本不同。`A`记录指向`IPv4`地址，`AAAA`记录指向`IPv6`地址。`AAAA`记录是`A`记录的升级版本。

### IPv4与IPv6
`IPv4`，是互联网协议（Internet Protocol，IP）的第四版，也是第一个被广泛使用的版本，是构成现今互联网技术的基础协议。`IPv4` 的下一个版本就是`IPv6`，在将来将取代目前被广泛使用的`IPv4`。
`IPv4`中规定IP地址长度为32位（按`TCP/IP`参考模型划分) ，即有`2^32-1`个地址。IPv6的提出最早是为了解决，随着互联网的迅速发展`IPv4`地址空间将被耗尽的问题。为了扩大地址空间，`IPv6`将IP地址的长度由32位增加到了128位。在IPv6的设计过程中除了一劳永逸地解决了地址短缺问题以外，还解决了IPv4中的其它问题，如：端到端IP连接、服务质量（QoS）、安全性、多播、移动性、即插即用等。

### TTL值
`TTL`－生存时间（Time To Live），表示解析记录在DNS服务器中的缓存时间，TTL的时间长度单位是秒，一般为3600秒。比如：在访问www.itbilu.com时，如果在DNS服务器的缓存中没有该记录，就会向某个NS服务器发出请求，获得该记录后，该记录会在DNS服务器上保存`TTL`的时间长度，在`TTL`有效期内访问`www.example.com`，DNS服务器会直接缓存中返回刚才的记录。

## 其他DNS工具
除了`dig`，还有一些其他小工具也可以使用。
### host 命令
`host`命令可以看作`dig`命令的简化版本，返回当前请求域名的各种记录。
``` bash
$ host github.com

github.com has address 192.30.252.121
github.com mail is handled by 5 ALT2.ASPMX.L.GOOGLE.COM.
github.com mail is handled by 10 ALT4.ASPMX.L.GOOGLE.COM.
github.com mail is handled by 10 ALT3.ASPMX.L.GOOGLE.COM.
github.com mail is handled by 5 ALT1.ASPMX.L.GOOGLE.COM.
github.com mail is handled by 1 ASPMX.L.GOOGLE.COM.

$ host facebook.github.com

facebook.github.com is an alias for github.map.fastly.net.
github.map.fastly.net has address 103.245.222.133
```
`host`命令也可以用于逆向查询，即从IP地址查询域名，等同于`dig -x <ip>`。
``` bash
$ host 192.30.252.153

153.252.30.192.in-addr.arpa domain name pointer pages.github.com.
```
### nslookup 命令
`nslookup`命令用于互动式地查询域名记录。
``` bash
$ nslookup

> facebook.github.io
Server:     192.168.1.253
Address:    192.168.1.253#53

Non-authoritative answer:
facebook.github.io  canonical name = github.map.fastly.net.
Name:   github.map.fastly.net
Address: 103.245.222.133

> 
```
### whois 命令
whois命令用来查看域名的注册情况。
``` bash
$ whois github.com
```