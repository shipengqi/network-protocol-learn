<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>Network protocol learning | DNS </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/network-protocol-learn/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/network-protocol-learn/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"DNS","path":"dns.html"},"data":{"navigation":{"logo":{"text":"Network Protocol Learn","type":"link","path":"index.html"},"main":[{"text":"IP","type":"link","path":"ip.html"},{"text":"物理层和链路层","type":"link","path":"physical_link.html"},{"text":"ICMP","type":"link","path":"icmp.html"},{"text":"网关","type":"link","path":"gateway.html"},{"text":"UDP","type":"link","path":"udp.html"},{"text":"TCP","type":"link","path":"tcp.html"},{"text":"HTTP","type":"link","path":"http.html"},{"text":"HTTPS","type":"link","path":"https.html"},{"text":"流媒体协议","type":"link","path":"stream.html"},{"text":"P2P 协议","type":"link","path":"p2p.html"},{"text":"DNS","type":"link","path":"dns.html"},{"text":"CDN","type":"link","path":"cdn.html"},{"text":"数据中心","type":"link","path":"data_center.html"},{"text":"VPN","type":"link","path":"vpn.html"},{"text":"移动网络","type":"link","path":"nemo.html"},{"text":"云中网络","type":"link","path":"cloud.html"},{"text":"容器网络","type":"link","path":"container.html"},{"text":"RPC","type":"link","path":"rpc.html"},{"text":"网络工具","type":"label"},{"text":"网络工具","type":"link","path":"net_tools.html"},{"text":"WireShark","type":"link","path":"wireshark.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/network-protocol-learn/issues/new"}]}},"config":{"timezone":"UTC","root":"/network-protocol-learn/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/network-protocol-learn/index.html" class="doc-navbar__logo"><img src="/network-protocol-learn/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Network Protocol Learn</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="DNS-服务器"><a href="#DNS-服务器" class="headerlink" title="DNS 服务器"></a>DNS 服务器</h2><p>网络世界是很难记住网站的 IP 地址，于是，就需要一个地址簿，根据名称，就可以查看具体的地址，就是 <strong>DNS 服务器</strong>。</p>
<p><strong>DNS 服务器，是高可用、高并发和分布式的</strong>。</p>
<h3 id="域名的层级"><a href="#域名的层级" class="headerlink" title="域名的层级"></a>域名的层级</h3><p>域名是有层级的，比如 <code>math.stackexchange.com</code> 用 <code>dig</code> 命令查询显示为 <code>math.stackexchange.com.</code>。这是因为所有域名的尾部，<br>都有一个根域名。</p>
<p>举例来说，<code>www.example.com</code> 真正的域名是 <code>www.example.com.root</code>，简写为 <code>www.example.com.</code>。因为，根域名 <code>.root</code> 对于所有域<br>名都是一样的，所以平时是省略的。根域名的下一级，叫做<strong>顶级域名</strong>（top-level domain，缩写为 TLD），比如 <code>.com</code>、<code>.net</code>；再下一<br>级叫做<strong>次级域名</strong>（second-level domain，缩写为 SLD），比如 <code>www.example.com</code> 里面的 <code>.example</code>，这一级域名是用户可以注册的。<br>再下一级是主机名（host），比如 <code>www.example.com</code> 里面的 <code>www</code>，又称为<strong>三级域名</strong>，这是用户在自己的域里面为服务器分配的名称，是用<br>户可以任意分配的。</p>
<p>DNS 服务器根据域名的层级，进行分级查询。<strong>每一级域名都有自己的 NS 记录，NS 记录指向该级域名的域名服务器</strong>。这些服务器知道下一级域<br>名的各种记录。所谓”分级查询”，就是从根域名开始，依次查询每一级域名的 NS 记录，直到查到最终的 IP 地址，过程大致如下：</p>
<ul>
<li>根 DNS 服务器：返回顶级域 DNS 服务器的 NS 记录和 A 记录（IP 地址）</li>
<li>顶级域 DNS 服务器：返回次级域 DNS 服务器的 NS 记录和 A 记录（IP 地址）</li>
<li>次级域（权威） DNS 服务器：返回相应主机的 IP 地址</li>
</ul>
<p>DNS 服务器怎么知道根域名服务器的 IP 地址的？</p>
<p><strong>根域名服务器的 NS 记录和 IP 地址一般是不会变化的，所以内置在 DNS 服务器里面</strong>。<br>目前，世界上一共有十三组根域名服务器，从 <code>a.toot-servers.net</code> 一直到 <code>a.toot-servers.net</code>。</p>
<h2 id="DNS-查询过程"><a href="#DNS-查询过程" class="headerlink" title="DNS 查询过程"></a>DNS 查询过程</h2><p>为了提高 DNS 的解析性能，很多网络都会就近部署 DNS 缓存服务器。于是，就有了以下的 DNS 解析流程。</p>
<ol>
<li>电脑客户端会发出一个 DNS 请求，问 <code>www.163.com</code> 的 IP 是啥啊，并发给本地域名服务器(本地 DNS)。那本地域名服务器(本地 DNS) 是什么<br>呢？如果是通过 DHCP 配置，本地 DNS 由你的网络服务商（ISP），如电信、移动等自动分配，它通常就在你网络服务商的某个机房。</li>
<li>本地 DNS 收到来自客户端的请求。你可以想象这台服务器上缓存了一张域名与之对应 IP 地址的大表格。如果能找到 <code>www.163.com</code>，它直接就<br>返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大，能告诉我 <code>www.163.com</code> 的IP 地址吗？” 根域名服务器不直接用于域名<br>解析，但能指明一条道路。</li>
<li>根 DNS 收到来自本地 DNS 的请求，发现后缀是 <code>.com</code>，说：“哦，<code>www.163.com</code> 啊，这个域名是由 <code>.com</code> 区域管理，我给你它的顶级域<br>名服务器的地址，你去问问它吧。</li>
<li>本地 DNS 转向问顶级域名服务器：“老二，你能告诉我 <code>www.163.com</code> 的IP 地址吗？”顶级域名服务器就是大名鼎鼎的比如<br><code>.com</code>、<code>.net</code>、<code>.org</code> 这些一级域名，它负责管理二级域名，比如 <code>163.com</code>，所以它能提供一条更清晰的方向。</li>
<li>顶级域名服务器说：“我给你负责 <code>www.163.com</code> 区域的次级域 DNS 服务器的地址，你去问它应该能问到。”</li>
<li>本地 DNS 转向问次级域 DNS 服务器：“您好，<code>www.163.com</code>对应的 IP 是啥呀？” <code>163.com</code> 的次级域 DNS 服务器，它是域名解析结果的原<br>出处。为啥叫次级域呢？就是我的域名我做主。</li>
<li>次级域 DNS 服务器查询后将对应的 IP 地址 <code>X.X.X.X</code> 告诉本地 DNS。</li>
<li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li>
</ol>
<p><img src="images/dns/dnsparse.jpg" alt></p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>DNS 除了可以通过名称映射为 IP 地址，它还可以做<strong>负载均衡</strong>。</p>
<p>DNS 首先可以做<strong>内部负载均衡</strong>。</p>
<p>例如，应用要访问数据库，配置这个数据库的域名，这样数据库如果 IP 地址修改，就不需要一个个修改应用的配置，直接修改 DNS 配置。<br>例如，当某个被访问的应用撑不住的时候，可以部署多个，只要配置域名，在域名解析的时候，我们只要配置策略，这次返回第一个 IP，下次返回第二<br>个 IP，就可以实现负载均衡了。</p>
<p>DNS 还可以做<strong>全局负载均衡</strong>。</p>
<p>例如，我们肯定希望北京的用户访问北京的数据中心，上海的用户访问上海的数据中心，这样，客户体验就会非常好，访问速度就会超快。这就<br>是全局负载均衡的概念。</p>
<h2 id="DNS-访问数据中心中对象存储上的静态资源"><a href="#DNS-访问数据中心中对象存储上的静态资源" class="headerlink" title="DNS 访问数据中心中对象存储上的静态资源"></a>DNS 访问数据中心中对象存储上的静态资源</h2><p>假设全国有多个数据中心，托管在多个运营商，每个数据中心三个可用区（Available Zone）。对象存储通过跨可用区部署，实现高可用性。在每<br>个数据中心中，都至少部署两个内部负载均衡器，内部负载均衡器后面对接多个对象存储的前置服务器（Proxy-server）。</p>
<p><img src="images/dns/dnslb.jpg" alt></p>
<ol>
<li>当一个客户端要访问 <code>object.yourcompany.com</code> 的时候，需要将域名转换为 IP 地址进行访问，所以它要请求本地 DNS 解析器。</li>
<li>本地 DNS 解析器先查看看本地的缓存是否有这个记录。如果有则直接使用。</li>
<li>如果本地无缓存，则需要请求本地的 DNS 服务器。</li>
<li>本地的 DNS 服务器一般部署在你的数据中心或者你所在的运营商的网络中，本地 DNS 服务器也需要看本地是否有缓存，如果有则返回。</li>
<li>如果本地缓存没有，本地 DNS 才需要递归地从根 DNS 服务器，查到 <code>.com</code> 的顶级域名服务器，最终查到 <code>yourcompany.com</code> 的次级<br>域 DNS 服务器，给本地 DNS 服务器，次级域 DNS 服务器按说会返回真实要访问的 IP 地址。</li>
</ol>
<p>对于不需要做全局负载均衡的简单应用来讲，<code>yourcompany.com</code> 的次级域 DNS 服务器可以直接将 <code>object.yourcompany.com</code> 这个域名解析为一<br>个或者多个 IP 地址，然后客户端可以通过多个 IP 地址，进行简单的轮询，实现简单的负载均衡。</p>
<p>但是对于复杂的应用，尤其是跨地域跨运营商的大型应用，则需要更加复杂的全局负载均衡机制，因而需要专门的设备或者服务器来做这件事情，<br>这就是<strong>全局负载均衡器（GSLB，Global Server LoadBalance）</strong>。</p>
<p>在 <code>yourcompany.com</code> 的 DNS 服务器中，一般是通过<strong>配置 CNAME 的方式</strong>，给 <code>object.yourcompany.com</code> 起一个别名，<br>例如 <code>object.vip.yourcomany.com</code>，然后告诉本地 DNS 服务器，让它请求 GSLB 解析这个域名，GSLB 就可以在解析这个域名的过程中，通过自<br>己的策略实现负载均衡。</p>
<p>图中画了两层的 GSLB，是因为分运营商和地域。我们希望不同运营商的客户，可以访问自己所属运营商机房中的资源，这样不跨运营商访问，有利于提高<br>吞吐量，减少时延.</p>
<ol>
<li>第一层 GSLB，通过查看请求它的本地 DNS 服务器所在的运营商，就知道用户所在的运营商。假设是移动，通过 CNAME 的方式，通过另一个别<br>名 <code>object.yd.yourcompany.com</code>，告诉本地 DNS 服务器去请求第二层的 GSLB。</li>
<li>第二层 GSLB，通过查看请求它的本地 DNS 服务器所在的地址，就知道用户所在的地理位置，然后将距离用户位置比较近的 Region 里面，<br>六个<strong>内部负载均衡</strong>（SLB，Server Load Balancer）的地址，返回给本地 DNS 服务器。</li>
<li>本地 DNS 服务器将结果返回给本地 DNS 解析器。</li>
<li>本地 DNS 解析器将结果缓存后，返回给客户端。</li>
<li>客户端开始访问属于相同运营商的距离较近的 Region 1 中的对象存储，当然客户端得到了六个 IP 地址，它可以通过负载均衡的方式，随机<br>或者轮询选择一个可用区进行访问。对象存储一般会有三个备份，从而可以实现对存储读写的负载均衡。</li>
</ol>
<h2 id="DNS的记录类型"><a href="#DNS的记录类型" class="headerlink" title="DNS的记录类型"></a>DNS的记录类型</h2><p>域名与IP之间的对应关系，称为”记录”（record）。根据使用场景，”记录”可以分成不同的类型（type），前面已经看到了有<code>A</code>记录和<code>NS</code>记录。<br>常见的DNS记录类型如下。</p>
<ol>
<li>A 记录：将域名指向一个IPv4地址（例如：100.100.100.100），需要增加A记录</li>
<li>CNAME 记录：如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加 CNAME 记录。这个域名一般是主机服务商提供的一个域名</li>
<li>MX 记录：建立电子邮箱服务，将指向邮件服务器地址，需要设置 MX 记录。建立邮箱时，一般会根据邮箱服务商提供的MX记录填写此记录</li>
<li>NS 记录：域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置 NS 记录</li>
<li>TXT 记录：可任意填写，可为空。一般做一些验证记录时会使用此项，如：做 SPF（反垃圾邮件）记录</li>
<li>AAAA 记录：将主机名（或域名）指向一个 IPv6 地址（例如：ff03:0:0:0:0:0:0:c1）</li>
<li>SRV 记录：添加服务记录服务器服务记录时会添加此项，SRV 记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）。</li>
<li>SOA 记录：SOA 叫做起始授权机构记录，NS用于标识多台域名解析服务器，SOA 记录用于在众多 NS 记录中那一台是主服务器</li>
<li>PTR 记录：PTR 记录是 A 记录的逆向记录，又称做 IP 反查记录或指针记录，负责将 IP 反向解析为域名</li>
<li>显性 URL 转发记录：将域名指向一个 http(s) 协议地址，访问域名时，自动跳转至目标地址。例如：将 <code>www.demo1.cn</code>显性转发<br>到 <code>www.demo2.com</code> 后，访问 <code>www.demo1.cn</code> 时，地址栏显示的地址为：<code>www.demo2.com</code>。</li>
<li>隐性 URL 转发记录：将域名指向一个 http(s) 协议地址，访问域名时，自动跳转至目标地址，隐性转发会隐藏真实的目标地址。例如：<br>将 <code>www.demo1.cn</code> 隐性转发到 <code>www.demo2.com</code> 后，访问 <code>www.demo1.cn</code> 时，地址栏显示的地址仍然是：<code>www.demo1.cn</code>。</li>
</ol>
<p>一般来说，为了服务的安全可靠，至少应该有两条 <code>NS</code> 记录，而 <code>A</code> 记录和 <code>MX</code> 记录也可以有多条，这样就提供了服务的冗余性，防止出现单点失败。</p>
<h2 id="HTTPDNS"><a href="#HTTPDNS" class="headerlink" title="HTTPDNS"></a>HTTPDNS</h2><p>有时候这个地址簿也经常给你指错路，明明距离你 500 米就有个吃饭的地方，非要把你推荐到 5 公里外。为什么会出现这样的情况呢？</p>
<p>当我们发出请求解析 DNS 的时候，首先，会先连接到运营商本地的 DNS 服务器，由这个服务器帮我们去整棵 DNS 树上进行解析，然后将解析的结果<br>返回给客户端。</p>
<h3 id="域名缓存问题"><a href="#域名缓存问题" class="headerlink" title="域名缓存问题"></a>域名缓存问题</h3><p>本地的 DNS 服务器会在本地做一个缓存，也就是说，不是每一个请求，它都会去访问次级域 DNS 服务器，而是访问过一次就把结果缓存到自己本地，当<br>其他人来问的时候，直接就返回这个缓存数据。</p>
<p>这就相当于导游去过一个饭店，自己脑子记住了地址，当有一个游客问的时候，他就凭记忆回答了，不用再去查地址簿。这样经常存在的一个问题是，人家<br>那个饭店明明都已经搬了，结果作为导游，他并没有刷新这个缓存，结果你辛辛苦苦到了这个地点，发现饭店已经变成了服装店，你是不是会非常失望？</p>
<p>再就是本地的缓存，往往使得全局负载均衡失败，因为上次进行缓存的时候，缓存中的地址不一定是这次访问离客户最近的地方，如果把这个地址返回<br>给客户，那肯定就会绕远路。</p>
<p>就像客户要吃西湖醋鱼，导游知道西湖边有一家，因为当时游客就在西湖边，可是，下一次客户在灵隐寺，想吃西湖醋鱼的时候，导游还指向西湖边的<br>那一家，那这就绕的太远了。</p>
<h3 id="域名转发问题"><a href="#域名转发问题" class="headerlink" title="域名转发问题"></a>域名转发问题</h3><p>缓存问题还是说本地域名解析服务，还是会去权威 DNS 服务器中查找，只不过不是每次都要查找。可以说这还是大导游、大中介。还有一些小导游、小<br>中介，有了请求之后，直接转发给其他运营商去做解析，自己只是外包了出去。</p>
<p>这样的问题是，如果是 A 运营商的客户，访问自己运营商的 DNS 服务器，如果 A 运营商去次级域 DNS 服务器查询的话，次级域 DNS 服务器知道<br>你是 A 运营商的，就返回给一个部署在A 运营商的网站地址，这样针对相同运营商的访问，速度就会快很多。</p>
<p>但是 A 运营商偷懒，将解析的请求转发给 B 运营商，B 运营商去次级域 DNS 服务器查询的话，次级域服务器会误认为，你是 B 运营商的，那就返回<br>给你一个在 B 运营商的网站地址吧，结果客户的每次访问都要跨运营商，速度就会很慢。</p>
<h3 id="出口-NAT-问题"><a href="#出口-NAT-问题" class="headerlink" title="出口 NAT 问题"></a>出口 NAT 问题</h3><p>很多机房都会配置 NAT，也即网络地址转换，使得从这个网关出去的包，都换成新的 IP 地址，当然请求返回的时候，在这个网关，再将 IP 地址转换回<br>去，所以对于访问来说是没有任何问题。</p>
<p>但是一旦做了网络地址的转换，次级域的 DNS 服务器，就没办法通过这个地址，来判断客户到底是来自哪个运营商，而且极有可能因为转换过后的地<br>址，误判运营商，导致跨运营商的访问。</p>
<h3 id="域名更新问题"><a href="#域名更新问题" class="headerlink" title="域名更新问题"></a>域名更新问题</h3><p>本地 DNS 服务器是由不同地区、不同运营商独立部署的。对域名解析缓存的处理上，实现策略也有区别，有的会偷懒，忽略域名解析结果的 TTL 时间限<br>制，在次级域 DNS 服务器解析变更的时候，解析结果在全网生效的周期非常漫长。但是有的时候，在 DNS 的切换中，场景对生效时间要求比较高。</p>
<p>例如双机房部署的时候，跨机房的负载均衡和容灾多使用 DNS 来做。当一个机房出问题之后，需要修改次级域 DNS，将域名指向新的 IP 地址，但是如<br>果更新太慢，那很多用户都会出现访问异常。</p>
<h3 id="解析延迟问题"><a href="#解析延迟问题" class="headerlink" title="解析延迟问题"></a>解析延迟问题</h3><p>DNS 的查询过程需要递归遍历多个 DNS 服务器，才能获得最终的解析结果，这会带来一定的时延，甚至会解析超时。</p>
<h3 id="HTTPDNS-的工作模式"><a href="#HTTPDNS-的工作模式" class="headerlink" title="HTTPDNS 的工作模式"></a>HTTPDNS 的工作模式</h3><p><strong>HTTPNDS 其实就是，不走传统的 DNS 解析，而是自己搭建基于 HTTP 协议的 DNS 服务器集群，分布在多个地点和多个运营商。当客户端需要 DNS 解<br>析的时候，直接通过 HTTP 协议进行请求这个服务器集群，得到就近的地址</strong>。</p>
<p>这就相当于每家基于 HTTP 协议，自己实现自己的域名解析，自己做一个自己的地址簿，而不使用统一的地址簿。但是默认的域名解析都是走 DNS 的，因<br>而使用HTTPDNS 需要绕过默认的 DNS 路径，就不能使用默认的客户端。使用 HTTPDNS 的，往往是手机应用，需要在手机端嵌入支持 HTTPDNS 的客户<br>端 SDK。</p>
<h4 id="解析-HTTPDNS-的工作模式。"><a href="#解析-HTTPDNS-的工作模式。" class="headerlink" title="解析 HTTPDNS 的工作模式。"></a>解析 HTTPDNS 的工作模式。</h4><p>在客户端的 SDK 里动态请求服务端，获取 HTTPDNS 服务器的 IP 列表，缓存到本地。随着不断地解析域名，SDK 也会在本地缓存 DNS 域名解析的结果。</p>
<p>当手机应用要访问一个地址的时候，首先看是否有本地的缓存，如果有就直接返回。这个缓存和本地 DNS 的缓存不一样的是，这个是手机应用自己做的，<br>而非整个运营商统一做的。如何更新、何时更新，手机应用的客户端可以和服务器协调来做这件事情。</p>
<p>如果本地没有，就需要请求 HTTPDNS 的服务器，在本地 HTTPDNS 服务器的 IP 列表中，选择一个发出 HTTP 的请求，会返回一个要访问的网<br>站的 IP 列表。</p>
<p>当所有这些都不工作的时候，可以切换到传统的 Local DNS 来解析。</p>
<h4 id="HTTPDNS-的缓存设计"><a href="#HTTPDNS-的缓存设计" class="headerlink" title="HTTPDNS 的缓存设计"></a>HTTPDNS 的缓存设计</h4><p>解析 DNS 过程复杂，通信次数多，对解析速度造成很大影响。为了加快解析，因而有了缓存，但是这又会产生缓存更新速度不及时的问题。最要命的是，<br>这两个方面都掌握在别人手中，也即本地 DNS 服务器手中，它不会为你定制，你作为客户端干着急没办法。</p>
<p>而 HTTPDNS 就是将解析速度和更新速度全部掌控在自己手中。一方面，解析的过程，不需要本地DNS服务递归的调用一大圈，一个 HTTP 的请求直接<br>搞定，要实时更新的时候，马上就能起作用；另一方面为了提高解析速度，本地也有缓存，缓存是在客户端 SDK 维护的，过期时间、更新时间，都可<br>以自己控制。</p>
<p>HTTPDNS 的缓存设计策略也是咱们做应用架构中常用的缓存设计模式，也即分为客户端、缓存、数据源三层。</p>
<p>只要是缓存模式，就存在缓存的过期、更新、不一致的问题，解决思路也是很像的。</p>
<p>例如 DNS 缓存在内存中，也可以持久化到存储上，从而 APP 重启之后，能够尽快从存储中加载上次累积的经常访问的网站的解析结果，就不需要每次<br>都全部解析一遍，再变成缓存。这有点像 Redis 是基于内存的缓存，但是同样提供持久化的能力，使得重启或者主备切换的时候，数据不会完全丢失。</p>
<p>SDK 中的缓存会严格按照缓存过期时间，如果缓存没有命中，或者已经过期，而且客户端不允许使用过期的记录，则会发起一次解析，保障记录是更新的。</p>
<p>解析可以<strong>同步进行</strong>，也就是直接调用 HTTPDNS 的接口，返回最新的记录，更新缓存；也可以<strong>异步进行</strong>，添加一个解析任务到后台，由后台任<br>务调用 HTTPDNS 的接口。</p>
<h4 id="HTTPDNS-的调度设计"><a href="#HTTPDNS-的调度设计" class="headerlink" title="HTTPDNS 的调度设计"></a>HTTPDNS 的调度设计</h4><p>由于客户端嵌入了 SDK，因而就不会因为本地 DNS 的各种缓存、转发、NAT，让次级域 DNS 服务器误会客户端所在的位置和运营商，而可以拿<br>到第一手资料。</p>
<p>在客户端，可以知道手机是哪个国家、哪个运营商、哪个省，甚至哪个市，HTTPDNS 服务端可以根据这些信息，选择最佳的服务节点返回。</p>
<p>在服务端，应用可以通过调用 HTTPDNS 的管理接口，配置不同服务质量的优先级、权重。HTTPDNS 会根据这些策略综合地理位置和线路状况算出一个<br>排序，优先访问当前那些优质的、时延低的IP 地址。</p>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/network-protocol-learn/script/doc.js"></script>

    

  </body>
</html>
