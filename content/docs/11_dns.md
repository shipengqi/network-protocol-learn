---
title: DNS
weight: 11
---


网络世界是很难记住网站的 IP 地址，于是，就需要一个地址簿，根据名称，就可以查看具体的地址，就是 **DNS 服务器**。

## DNS 服务器

**DNS 服务器，是高可用、高并发和分布式的**。

### 域名的层级

域名是有层级的，比如 `math.stackexchange.com` 用 `dig` 命令查询显示为 `math.stackexchange.com.`。这是因为所有域名的尾部，都有一个根域名。

举例来说，`www.example.com` 真正的域名是 `www.example.com.root`，简写为 `www.example.com.`。

- 因为，**根域名 `.root` 对于所有域名都是一样的，所以平时是省略的**。
- 根域名的下一级，叫做**顶级域名**（top-level domain，缩写为 TLD），比如 `.com`、`.net`；
- 再下一级叫做**次级域名**（second-level domain，缩写为 SLD），比如 `www.example.com` 里面的 `.example`，**次级域名是用户可以注册的**。
- 再下一级是主机名（host），比如 `www.example.com` 里面的 `www`，又称为**三级域名**，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。

DNS 服务器根据域名的层级，进行分级查询。

**每一级域名都有自己的 NS 记录，NS 记录指向该级域名的域名服务器**。

这些服务器知道下一级域名的各种记录。所谓"分级查询"，就是从根域名开始，依次查询每一级域名的 NS 记录，直到查到最终的 IP 地址，过程大致如下：

- 根 DNS 服务器：返回顶级域 DNS 服务器的 NS 记录和 A 记录（IP 地址）
- 顶级域 DNS 服务器：返回次级域 DNS 服务器的 NS 记录和 A 记录（IP 地址）
- 次级域（权威） DNS 服务器：返回相应主机的 IP 地址

DNS 服务器怎么知道根域名服务器的 IP 地址的？

**根域名服务器的 NS 记录和 IP 地址一般是不会变化的，所以内置在 DNS 服务器里面**。
目前，世界上一共有十三组根域名服务器，从 `a.toot-servers.net` 一直到 `a.toot-servers.net`。

## DNS 查询过程

为了提高 DNS 的解析性能，很多网络都会就近部署 DNS 缓存服务器。于是，就有了以下的 DNS 解析流程。

1. 电脑客户端会发出一个 DNS 请求，问 `www.163.com` 的 IP 是啥啊，并发给本地域名服务器(本地 DNS)。那本地域名服务器(本地 DNS) 是什么呢？如果是通过 DHCP 配置，本地 DNS 由你的网络服务商（ISP），如电信、移动等自动分配，它通常就在你网络服务商的某个机房。
2. 本地 DNS 收到来自客户端的请求。你可以想象这台服务器上缓存了一张域名与之对应 IP 地址的大表格。如果能找到 `www.163.com`，它直接就返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大，能告诉我 `www.163.com` 的IP 地址吗？” 根域名服务器不直接用于域名解析，但能指明一条道路。
3. 根 DNS 收到来自本地 DNS 的请求，发现后缀是 `.com`，说：“哦，`www.163.com` 啊，这个域名是由 `.com` 区域管理，我给你它的顶级域名服务器的地址，你去问问它吧。
4. 本地 DNS 转向问顶级域名服务器：“老二，你能告诉我 `www.163.com` 的 IP 地址吗？”顶级域名服务器就是大名鼎鼎的比如`.com`、`.net`、`.org` 这些一级域名，它负责管理二级域名，比如 `163.com`，所以它能提供一条更清晰的方向。
5. 顶级域名服务器说：“我给你负责 `www.163.com` 区域的次级域 DNS 服务器的地址，你去问它应该能问到。”
6. 本地 DNS 转向问次级域 DNS 服务器：“您好，`www.163.com`对应的 IP 是啥呀？” `163.com` 的次级域 DNS 服务器，它是域名解析结果的原出处。为啥叫次级域呢？就是我的域名我做主。
7. 次级域 DNS 服务器查询后将对应的 IP 地址 `X.X.X.X` 告诉本地 DNS。
8. 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。

![](images/dns/dnsparse.jpg)

## 负载均衡

DNS 除了可以通过名称映射为 IP 地址，它还可以做**负载均衡**。

DNS 首先可以做**内部负载均衡**。

例如，应用要访问数据库，配置这个数据库的域名，这样数据库如果 IP 地址修改，就不需要一个个修改应用的配置，直接修改 DNS 配置。

例如，当某个被访问的应用撑不住的时候，可以部署多个，只要配置域名，在域名解析的时候，我们只要配置策略，这次返回第一个 IP，下次返回第二个 IP，就可以实现负载均衡了。

DNS 还可以做**全局负载均衡**。

例如，我们肯定希望北京的用户访问北京的数据中心，上海的用户访问上海的数据中心，这样，客户体验就会非常好，访问速度就会超快。这就是全局负载均衡的概念。

## DNS 访问数据中心中对象存储上的静态资源

假设全国有多个数据中心，托管在多个运营商，每个数据中心三个可用区（Available Zone）。对象存储通过跨可用区部署，实现高可用性。在每个数据中心中，都至少部署两个内部负载均衡器，内部负载均衡器后面对接多个对象存储的前置服务器（Proxy-server）。

![](images/dns/dnslb.jpg)

1. 当一个客户端要访问 `object.yourcompany.com` 的时候，需要将域名转换为 IP 地址进行访问，所以它要请求本地 DNS 解析器。
2. 本地 DNS 解析器先查看看本地的缓存是否有这个记录。如果有则直接使用。
3. 如果本地无缓存，则需要请求本地的 DNS 服务器。
4. 本地的 DNS 服务器一般部署在你的数据中心或者你所在的运营商的网络中，本地 DNS 服务器也需要看本地是否有缓存，如果有则返回。
5. 如果本地缓存没有，本地 DNS 才需要递归地从根 DNS 服务器，查到 `.com` 的顶级域名服务器，最终查到 `yourcompany.com` 的次级
域 DNS 服务器，给本地 DNS 服务器，次级域 DNS 服务器按说会返回真实要访问的 IP 地址。

对于不需要做全局负载均衡的简单应用来讲，`yourcompany.com` 的次级域 DNS 服务器可以直接将 `object.yourcompany.com` 这个域名解析为一个或者多个 IP 地址，然后客户端可以通过多个 IP 地址，进行简单的轮询，实现简单的负载均衡。

但是对于复杂的应用，尤其是跨地域跨运营商的大型应用，则需要更加复杂的全局负载均衡机制，因而需要专门的设备或者服务器来做这件事情，这就是**全局负载均衡器（GSLB，Global Server LoadBalance）**。

在 `yourcompany.com` 的 DNS 服务器中，一般是通过**配置 CNAME 的方式**，给 `object.yourcompany.com` 起一个别名，例如 `object.vip.yourcomany.com`，然后告诉本地 DNS 服务器，让它请求 GSLB 解析这个域名，**GSLB 就可以在解析这个域名的过程中，通过自己的策略实现负载均衡**。

图中画了两层的 GSLB，是因为分运营商和地域。我们希望不同运营商的客户，可以访问自己所属运营商机房中的资源，这样不跨运营商访问，有利于提高
吞吐量，减少时延.

1. 第一层 GSLB，通过查看请求它的本地 DNS 服务器所在的运营商，就知道用户所在的运营商。假设是移动，通过 CNAME 的方式，通过另一个别名 `object.yd.yourcompany.com`，告诉本地 DNS 服务器去请求第二层的 GSLB。
2. 第二层 GSLB，通过查看请求它的本地 DNS 服务器所在的地址，就知道用户所在的地理位置，然后将距离用户位置比较近的 Region 里面，六个**内部负载均衡**（SLB，Server Load Balancer）的地址，返回给本地 DNS 服务器。
3. 本地 DNS 服务器将结果返回给本地 DNS 解析器。
4. 本地 DNS 解析器将结果缓存后，返回给客户端。
5. 客户端开始访问属于相同运营商的距离较近的 Region 1 中的对象存储，当然客户端得到了六个 IP 地址，它可以通过负载均衡的方式，随机或者轮询选择一个可用区进行访问。对象存储一般会有三个备份，从而可以实现对存储读写的负载均衡。

## DNS 的记录类型

域名与 IP 之间的对应关系，称为"记录"（record）。根据使用场景，"记录"可以分成不同的类型（type），前面已经看到了有`A`记录和`NS`记录。

常见的 DNS 记录类型如下：

1. **A 记录：将域名指向一个 IPv4 地址**（例如：100.100.100.100），需要增加 A 记录
2. **CNAME 记录：如果将域名指向一个域名**，实现与被指向域名相同的访问效果，需要增加 CNAME 记录。这个域名一般是主机服务商提供的一个域名
3. **MX 记录：建立电子邮箱服务**，将指向邮件服务器地址，需要设置 MX 记录。建立邮箱时，一般会根据邮箱服务商提供的MX记录填写此记录
4. **NS 记录：域名解析服务器记录，如果要将子域名指定某个域名服务器来解析，需要设置 NS 记录**
5. TXT 记录：可任意填写，可为空。一般做一些验证记录时会使用此项，如：做 SPF（反垃圾邮件）记录
6. **AAAA 记录：将主机名（或域名）指向一个 IPv6 地址**（例如：ff03:0:0:0:0:0:0:c1）
7. SRV 记录：添加服务记录服务器服务记录时会添加此项，SRV 记录了哪台计算机提供了哪个服务。格式为：服务的名字.协议的类型（例如：_example-server._tcp）。
8. SOA 记录：SOA 叫做起始授权机构记录，NS 用于标识多台域名解析服务器，SOA 记录用于在众多 NS 记录中那一台是主服务器
9. PTR 记录：PTR 记录是 A 记录的逆向记录，又称做 IP 反查记录或指针记录，负责将 IP 反向解析为域名
10. 显性 URL 转发记录：将域名指向一个 http(s) 协议地址，访问域名时，自动跳转至目标地址。例如：将 `www.demo1.cn`显性转发
到 `www.demo2.com` 后，访问 `www.demo1.cn` 时，地址栏显示的地址为：`www.demo2.com`。
11. 隐性 URL 转发记录：将域名指向一个 http(s) 协议地址，访问域名时，自动跳转至目标地址，隐性转发会隐藏真实的目标地址。例如：
将 `www.demo1.cn` 隐性转发到 `www.demo2.com` 后，访问 `www.demo1.cn` 时，地址栏显示的地址仍然是：`www.demo1.cn`。

一般来说，为了服务的安全可靠，至少应该有两条 `NS` 记录，而 `A` 记录和 `MX` 记录也可以有多条，这样就提供了服务的冗余性，防止出现单点失败。

## HTTPDNS

有时候这个地址簿也经常给你指错路，明明距离你 500 米就有个吃饭的地方，非要把你推荐到 5 公里外。为什么会出现这样的情况呢？

当我们发出请求解析 DNS 的时候，首先，会先连接到运营商本地的 DNS 服务器，由这个服务器帮我们去整棵 DNS 树上进行解析，然后将解析的结果返回给客户端。

### 域名缓存问题

本地的 DNS 服务器会在本地做一个缓存，也就是说，不是每一个请求，它都会去访问次级域 DNS 服务器，而是访问过一次就把结果缓存到自己本地，当其他人来问的时候，直接就返回这个缓存数据。

这就相当于导游去过一个饭店，自己脑子记住了地址，当有一个游客问的时候，他就凭记忆回答了，不用再去查地址簿。这样经常存在的一个问题是，人家那个饭店明明都已经搬了，结果作为导游，他并没有刷新这个缓存，结果你辛辛苦苦到了这个地点，发现饭店已经变成了服装店，你是不是会非常失望？

再就是本地的缓存，往往使得全局负载均衡失败，因为上次进行缓存的时候，缓存中的地址不一定是这次访问离客户最近的地方，如果把这个地址返回给客户，那肯定就会绕远路。

就像客户要吃西湖醋鱼，导游知道西湖边有一家，因为当时游客就在西湖边，可是，下一次客户在灵隐寺，想吃西湖醋鱼的时候，导游还指向西湖边的那一家，那这就绕的太远了。

### 域名转发问题

缓存问题还是说本地域名解析服务，还是会去权威 DNS 服务器中查找，只不过不是每次都要查找。可以说这还是大导游、大中介。还有一些小导游、小中介，有了请求之后，直接转发给其他运营商去做解析，自己只是外包了出去。

这样的问题是，如果是 A 运营商的客户，访问自己运营商的 DNS 服务器，如果 A 运营商去次级域 DNS 服务器查询的话，次级域 DNS 服务器知道你是 A 运营商的，就返回给一个部署在A 运营商的网站地址，这样针对相同运营商的访问，速度就会快很多。

但是 A 运营商偷懒，将解析的请求转发给 B 运营商，B 运营商去次级域 DNS 服务器查询的话，次级域服务器会误认为，你是 B 运营商的，那就返回给你一个在 B 运营商的网站地址吧，结果客户的每次访问都要跨运营商，速度就会很慢。

### 出口 NAT 问题

很多机房都会配置 NAT，也即网络地址转换，使得从这个网关出去的包，都换成新的 IP 地址，当然请求返回的时候，在这个网关，再将 IP 地址转换回去，所以对于访问来说是没有任何问题。

但是一旦做了网络地址的转换，次级域的 DNS 服务器，就没办法通过这个地址，来判断客户到底是来自哪个运营商，而且极有可能因为转换过后的地址，误判运营商，导致跨运营商的访问。

### 域名更新问题

本地 DNS 服务器是由不同地区、不同运营商独立部署的。对域名解析缓存的处理上，实现策略也有区别，有的会偷懒，忽略域名解析结果的 TTL 时间限制，在次级域 DNS 服务器解析变更的时候，解析结果在全网生效的周期非常漫长。但是有的时候，在 DNS 的切换中，场景对生效时间要求比较高。

例如双机房部署的时候，跨机房的负载均衡和容灾多使用 DNS 来做。当一个机房出问题之后，需要修改次级域 DNS，将域名指向新的 IP 地址，但是如果更新太慢，那很多用户都会出现访问异常。

### 解析延迟问题

DNS 的查询过程需要递归遍历多个 DNS 服务器，才能获得最终的解析结果，这会带来一定的时延，甚至会解析超时。

### HTTPDNS 的工作模式

**HTTPNDS 其实就是，不走传统的 DNS 解析，而是自己搭建基于 HTTP 协议的 DNS 服务器集群，分布在多个地点和多个运营商。当客户端需要 DNS 解析的时候，直接通过 HTTP 协议进行请求这个服务器集群，得到就近的地址**。

这就相当于每家基于 HTTP 协议，自己实现自己的域名解析，自己做一个自己的地址簿，而不使用统一的地址簿。但是默认的域名解析都是走 DNS 的，因而**使用 HTTPDNS 需要绕过默认的 DNS 路径，就不能使用默认的客户端**。使用 HTTPDNS 的，往往是手机应用，需要在手机端嵌入支持 HTTPDNS 的客户端 SDK。

#### 解析 HTTPDNS 的工作模式

在客户端的 SDK 里动态请求服务端，获取 HTTPDNS 服务器的 IP 列表，缓存到本地。随着不断地解析域名，SDK 也会在本地缓存 DNS 域名解析的结果。

当手机应用要访问一个地址的时候，首先看是否有本地的缓存，如果有就直接返回。这个缓存和本地 DNS 的缓存不一样的是，这个是手机应用自己做的，而非整个运营商统一做的。如何更新、何时更新，手机应用的客户端可以和服务器协调来做这件事情。

如果本地没有，就需要请求 HTTPDNS 的服务器，在本地 HTTPDNS 服务器的 IP 列表中，选择一个发出 HTTP 的请求，会返回一个要访问的网站的 IP 列表。

当所有这些都不工作的时候，可以切换到传统的 Local DNS 来解析。

#### HTTPDNS 的缓存设计

**解析 DNS 过程复杂，通信次数多，对解析速度造成很大影响。为了加快解析，因而有了缓存，但是这又会产生缓存更新速度不及时的问题**。最要命的是，这两个方面都掌握在别人手中，也即本地 DNS 服务器手中，它不会为你定制，你作为客户端干着急没办法。

而 HTTPDNS 就是将解析速度和更新速度全部掌控在自己手中。

- 一方面，解析的过程，不需要本地 DNS 服务递归的调用一大圈，一个 HTTP 的请求直接搞定，要实时更新的时候，马上就能起作用；
- 另一方面为了提高解析速度，本地也有缓存，缓存是在客户端 SDK 维护的，过期时间、更新时间，都可以自己控制。

HTTPDNS 的缓存设计策略也是咱们做应用架构中常用的缓存设计模式，也即分为客户端、缓存、数据源三层。

只要是缓存模式，就存在缓存的过期、更新、不一致的问题，解决思路也是很像的。

例如 DNS 缓存在内存中，也可以持久化到存储上，从而 APP 重启之后，能够尽快从存储中加载上次累积的经常访问的网站的解析结果，就不需要每次都全部解析一遍，再变成缓存。这有点像 Redis 是基于内存的缓存，但是同样提供持久化的能力，使得重启或者主备切换的时候，数据不会完全丢失。

SDK 中的缓存会严格按照缓存过期时间，如果缓存没有命中，或者已经过期，而且客户端不允许使用过期的记录，则会发起一次解析，保障记录是更新的。

解析可以**同步进行**，也就是直接调用 HTTPDNS 的接口，返回最新的记录，更新缓存；也可以**异步进行**，添加一个解析任务到后台，由后台任务调用 HTTPDNS 的接口。

#### HTTPDNS 的调度设计

由于客户端嵌入了 SDK，因而就不会因为本地 DNS 的各种缓存、转发、NAT，让次级域 DNS 服务器误会客户端所在的位置和运营商，而可以拿到第一手资料。

在客户端，可以知道手机是哪个国家、哪个运营商、哪个省，甚至哪个市，HTTPDNS 服务端可以根据这些信息，选择最佳的服务节点返回。

在服务端，应用可以通过调用 HTTPDNS 的管理接口，配置不同服务质量的优先级、权重。HTTPDNS 会根据这些策略综合地理位置和线路状况算出一个排序，优先访问当前那些优质的、时延低的 IP 地址。
