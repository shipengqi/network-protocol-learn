---
title: TCP
weight: 6
---

TCP 认为网络环境是恶劣的，丢包、乱序、重传，拥塞都是常有的事情，一言不合就可能送达不了，因而要从算法层面来保证可靠性。 主要有下面几个方面：

- **对每个包提供校验和**
- **包的序列号解决了接收数据的乱序、重复问题**
- **重传机制**
- **流量控制、拥塞控制**

## 什么是流

TCP 面向字节流的协议。**流的含义是没有固定的报文边界**。

假设调用 2 次 write 函数往 socket 里依次写 500 字节、800 字节。write 函数只是把字节拷贝到内核缓冲区，最终会以多少条报文发送出去是不确定的：

- 情况 1：分为两条报文依次发出去 500 字节 和 800 字节数据
- 情况 2：两部分数据合并为一个长度为 1300 字节的报文，一次发送
- 情况 3：第一部分的 500 字节与第二部分的 500 字节合并为一个长度为 1000 字节的报文，第二部分剩下的 300 字节单独作为一个报文发送
- 情况 4：第一部分的 400 字节单独发送，剩下100字节与第二部分的 800 字节合并为一个 900 字节的包一起发送。
- 情况 N：更多可能的拆分组合

上面出现的情况**取决于诸多因素：路径最大传输单元 MTU、发送窗口大小、拥塞窗口大小等**。

## TCP 包头

![](images/tcp/tcp-pack.jpg)

### 序号

通过 TCP 传输的字节流的每个字节都分配了序列号，**序列号（Sequence number，SEQ）指的是本报文段第一个字节的序列号**。为了解决乱序，重复的问题。

序列号加上报文的长度，就可以确定传输的是哪一段数据。

**在 SYN 报文中，序列号用于交换彼此的初始序列号，在其它报文中，序列号用于保证包的顺序**。

#### 初始序列号

在**建立连接之初，通信双方都会各自选择一个序列号，称之为初始序列号**（Initial Sequence Number, ISN）。在建立连接时，通信双方通过 SYN 报文交换彼此的 ISN。

**初始序列号是通过源地址、目标地址、源端口、目标端口和随机因子通过 MD5 进行进行计算。再加入“时间因子”计算得出**。

![](images/tcp/isn.jpg)

### 确认序号

发出去的包要确认，不然怎么知道有没有收到。没有收到就重发，直到送达。

TCP 使用**确认序号**（Acknowledgment number, ACK）来**告知对方下一个期望接收的序列号，小于此确认号的所有字节都已经收到**。

- **ACK 包本身不需要被确认**，否则就会无穷无尽死循环了
- **确认号永远是表示小于此确认号的字节都已经收到**

### 状态位

双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。

- **SYN**（Synchronize）：发起一个连接，同步双方的初始序列号
- **ACK**（Acknowledge）：确认数据包
- **RST**（Reset）：表示复位，用来关闭异常连接
- **FIN**（Finish）：结束连接，通知对方我发完了所有数据，准备断开连接，后面我不会再发数据包给你了。
- **PSH**（Push）：告知对方这些数据包收到以后应该马上交给上层应用，不能缓存起来

### 窗口大小

TCP 要做**流量控制**，**双方各自声明一个窗口，表示自己当前能够的处理能力，避免发的太快或者太慢**。

TCP 还会做**拥塞控制**。用于表示窗口大小的 "Window Size" 只有 16 位，也就是窗口大小最大是 65535 字节（64KB）。

## 最大传输单元

**数据链路层传输的帧大小是有限制的，不能把一个太大的包直接塞给链路层**，这个限制被称为
**最大传输单元**（Maximum Transmission Unit, MTU）。

**以太网的帧最小的帧是 64 字节**，除去 14 字节头部和 4 字节 CRC 字段，**有效荷载最小为 46 字节**。最大的帧是 1518 字节，**有效荷载最大为 1500 字节**，这个值就是以太网的 **MTU**。计算一下传输 100KB 的数据，至少需要 `(100 * 1024 / 1500) = 69` 个以太网帧。

![](images/tcp/eth-pack.jpg)

**不同的数据链路层的 MTU 是不同的**。通过 `netstat -i` 可以查看网卡的 mtu。

### 路径 MTU

**一个包从发送端传输到接收端，中间要跨越很多个网络，每条链路的 MTU 都可能不一样**，这个通信过程中最小的 MTU 称为**路径 MTU**（Path MTU）。就好比开车有时候开的是双向 4 车道，有时候可能是乡间小路一样。

路径 MTU 就跟木桶效应是一个道理，木桶的盛水量由最短的那条短板决定，**路径 MTU 也是由通信链条中最小的 MTU 决定**。

## IP 分段

IPv4 数据报的最大大小为 65535 字节，这已经远远超过了以太网的 MTU，而且有些网络还会开启巨帧（Jumbo Frame）能达到 9000 字节。

**当一个 IP 数据包大于 MTU 时，IP 会把数据报文进行切割为多个小的片段 (小于 MTU）**，使得这些小的报文可以通过链路层进行传输。

IP 头部中有一个 13 位表示**分片偏移量**的字段，用来**表示该分段在原始数据报文中的位置**。

例如下面的包：
![](images/tcp/ip-offset.jpg)

- `More fragments` 处于 **`set` 状态，表示后面还有其它分片**。
- `Fragment offset: 185` 这里并不是**表示分片偏移量为 185**，wireshark 这里显示的时候除以了 8，真实的分片偏移量为 `185 * 8 = 1480`。
- 如果 `More fragments` 处于 `Not set` 状态，表示这是最后一个分片了。

## TCP 最大段大小

**TCP 为了避免被发送方分片，会主动把数据分割成小段再交给网络层**，最大的分段大小称之为 **MSS**（Max Segment Size）。

```
MSS = MTU - IP 头大小 - TCP 头大小
```

**这样一个 MSS 的数据恰好能装进一个 MTU 而不用分片**。

在以太网中 TCP 的 `MSS = 1500（MTU） - 20（IP 头大小） - 20（TCP 头大小）= 1460`。

**TCP 有一个 socket 选项 `TCP_MAXSEG`，可以用来设置此次连接的 MSS，如果设置了这个选项，则 MSS 不能超过这个值**。

## 端口号（程序地址）

**在传输层也有这种类似于地址的概念，那就是端口号**。端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为**程序地址**。

一台计算机上同时可以运行多个程序。传输层协议正是**利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输**。

### 为什么端口号有 65535 个？

因为在 **TCP、UDP 协议报文的头，会分别有 16 位二进制来存储源端口号和目标端口号**。

所以端口个数是 `2^16=65536` 个，但是 **0 号端口用来表示所有端口（`0` 被保留，不可用于有效通信），所以实际可用的端口号是 65535 个**。

### 端口号的确定

- **标准既定的端口号**：这种方法也叫静态方法。它是指**每个应用程序都有其指定的端口号**。但并不是说可以随意使用任何一个端口号。例如 HTTP、FTP、TELNET 等广为使用的应用协议中所使用的端口号就是固定的。这些端口号被称为**知名端口号**，分布在 `0~1023` 之间，我们在编写自己的网络应用服务时，尽量不要使用这些端口号。
- **时序分配法**：服务器有必要确定监听端口号，以让客户端程序访问服务器上的服务。但是客户端没必要确定端口号。在这种方法下，**客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配**，客户端使用的**临时端口号**，操作系统分配的一般都是大于 10000 的。

### 一台主机上只能保持最多 65535 个 TCP 连接么？

不是的，要理解如何确定一条连接的唯一性。而且服务器和客户端要分开讨论，以下的讨论都基于服务器和客户端都只有 1 个 IP 地址。

#### 客户端

客户端应用程序完全可以不用自己设置端口号，而全权交给操作系统进行分配，可用的**端口号只有 6 万多，从这个角度考虑，客户端最多只能发起 6 万多条 TCP 连接**。但其实也不是。

从 TCP 连接四元组来考虑：源 IP 地址、源端口、目的 IP 地址和目的端口。只要服务器的 IP 或者端口不一样，即使客户端的 IP 和端口是一样的。这个四元组也是属于一条完全不同的新连接。

比如客户端的 IP 和端口完全一样，但由于服务器侧的端口不同，所以仍然是两条不同的连接。

问题来了，**客户端同一个端口可以连接不同的服务器吗？答案是可以的**。

**客户端只要启动时不显示绑定到某个端口上，内核是可以使用一个端口连不同的服务端，内核会自己进行选择并恰当地复用的，而且完全不会产生数据混乱**，因为“**源 IP 地址、目标 IP 地址、源端口号以及目标端口号就能唯一性确定一个 TCP 连接**”。那么对客户端来说，四元组里有 3 个可变，自然客户端能同时支持的连接数比服务器还要大得多（服务端只有两个可变）。

#### 服务端

TCP 连接四元组：源 IP 地址、源端口、目的 IP 地址和目的端口。

很明显当四元组中任意一个元素发生了改变，那么就代表的是一条完全不同的新连接。服务端的 IP 地址和端口是不变的，那么对服务端来说，四元组里有 2 个可变。

IP 地址是一个 32 位的整数，所以源 IP 最大有 2 的 32 次方这么多个。端口是一个 16 位的整数，所以端口的数量就是 2 的 16 次方。`2 的 32 次方（ip 数）× 2 的 16 次方（port 数）` 大约等于两百多万亿。所以理论上，每个 server 可以接收的连接上限就是两百多万亿。当然实际上做不到，目前工程实践中可以达到的连接数在千万级别。

## 三次握手

![](images/tcp/handshake.jpg)

1. 客户端发送的一个段是 SYN 报文，这个报文只有 SYN 标记被置位。SYN 报文不携带数据，但是它占用一个序号（因为 SYN 段需要对方的确认，需要占用一个序列号），下次发送数据序列号要加一。客户端会随机选择一个数字作为初始序列号（ISN）。
2. 服务端收到客户端的 SYN 段以后，将 SYN 和 ACK 标记都置位。
3. 客户端发送三次握手最后一个 ACK 段，这个 ACK 段用来确认收到了服务端发送的 SYN 段。因为这个 ACK 段不携带任何数据，且不需要再被确认，这个 ACK 段不消耗任何序列号。

**三次握手除了建立连接，还要沟通 TCP 包的序号**。A 告诉 B 我发起的请求从哪个序号开始，B 告诉 A，B 发起的包的序号从哪个开始。

为什么序号不都从 1 开始？是为了**防止冲突**。

例如，A 连上 B，发送了 1，2，3 三个包，但是 3 丢失了或者绕路了，重新发送，但是后来 A 又掉线了，重新连上 B 后，又从 1 开始发，但是只发了 1，2，但是上次绕路的那个 3 又回来了，发给了 B，B 自然认为，这就是下一个包，于是发生了错误。

因而，**每个连接都要有不同的序号，起始序号是随时间变化的，32 位，每 4S 加一**。

### 为什么握手要三次

为了实现可靠数据传输， TCP 协议的通信双方，都必须维护一个序列号（因为是 TCP 是全双工，所以每个方向都要维护一个序列号），以标识发送出去的数据包中，哪些是已经被对方收到的。

举例说明：发送方在发送数据包时， 同时送上一个序号(假设 500)，那么接收方收到这个数据包以后，就可以回复一个确认号（`510 = 500 + 10`，**TCP 发送的报文，是可以批量确认的，并不一定每次都是序列号加 1**）告诉发送方 “我已经收到了你的数据包， 你可以发送下一个数据包，序号从 511 开始” 。

三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤。

如果只是两次握手，至多只有连接发起方的起始序列号能被确认，另一方选择的序列号则得不到确认。

#### 为什么不是四次？

三次握手后，通信的双方都已经知道了对方序列号起始值，也确认了对方知道自己序列号起始值（也代表双方都能确定连接是通的），第四次握手已经毫无必要了。

#### TCP 的三次握手的漏洞 - SYN 洪泛攻击

在 TCP 三次握手中有一个缺陷，被称为 SYN 洪泛攻击。

三次握手中有一个第二次握手，服务端向客户端应答请求，应答请求是需要客户端 IP 的，而且因为握手过程没有完成，操作系统使用队列维持这个状态（Linux 2.2 以后，**这个队列大小参数可以通过 `/proc/sys/net/ipv4/tcp_max_syn_backlog` 设置，默认是 1024 个**）。

于是**攻击者就伪造这个 IP，往服务器端狂发送第一次握手的内容，当然第一次握手中的客户端 IP 地址是伪造的，从而服务端就不停的向这个伪造的 IP 发送 ACK 应答，但是第二次握手是不会有应答的，所以导致服务器在队列中维护了大量的连接，而拒绝正常的连接**。

面对这种攻击，有以下的解决方案，最好的方案是防火墙。

1. 无效连接监视释放

这种方法不停监视所有的连接，包括三次握手的，还有握手一次的，反正是所有的，当达到一定阈值时释放这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，不管是正常的还是攻击的，所以这种方式不推荐。

2. 延缓 TCB 分配方法

一般的做完第一次握手之后，服务器就需要为该请求分配一个 TCB（连接控制资源），通常这个资源需要 200 多个字节。延迟 TCB 的分配，当正常连接建立起来后再分配 TCB 则可以有效地减轻服务器资源的消耗。

3. 使用防火墙

防火墙在先确认 IP 是有效性的，才向内部的服务器（Listener）发起 SYN 请求，

## 四次挥手

![](images/tcp/wave.jpg)

A：B 啊，我不想玩了。
B：哦，你不想玩了啊，我知道了。

这个时候，还只是 A 不想玩了，也即 A 不会再发送数据，但是 B 能不能在 ACK 的时候，直接关闭呢？

当然不可以了，很有可能 A 是发完了最后的数据就准备不玩了，但是 B 还没做完自己的事情，还是可以发送数据的，所以称为**半关闭**（half-close）的状态。

B：A 啊，好吧，我也不玩了，拜拜。
A：好的，拜拜

这样整个连接就关闭了。

> **FIN 段是可以携带数据的，比如客户端可以在它最后要发送的数据块可以“捎带” FIN 段**。

但是这个过程有没有异常情况呢？

1. A 说完“不玩了”之后，直接跑路，是会有问题的，因为 B 还没有发起结束，而如果 A 跑路，B 就算发起结束，也得不到回答，B 就不知道该怎么办了。
2. A 说完“不玩了”，B 直接跑路，也是有问题的，因为 A 不知道 B 是还有事情要处理，还是过一会儿会发送结束。A 没有收到回复，则 A 会重新发送“不玩了”。

TCP 协议专门设计了几个状态来处理这些问题。

A 收到 “B 说知道了”，就进入 FIN_WAIT_2 的状态，如果这个时候 B 直接跑路，则 A 将永远在这个状态。TCP 协议里面并没有对这个状态的处理，但是 Linux 有，可以调整 `tcp_fin_timeout` 这个参数，设置一个**超时时间**。

如果 B 没有跑路，发送了 “B 也不玩了” 的请求到达 A 时，A 发送“知道 B 也不玩了”的 ACK 后，从 FIN_WAIT_2 状态结束，按说 A 可以跑路了，但是最后的这个 ACK 万一 B 收不到呢？则 B 会重新发一个“B 不玩了”，这个时候 A 已经跑路了的话，B 就再也收不到 ACK 了，因而 TCP 协议要求 A 最后等待一段时间 TIME_WAIT，这个时间要足够长，长到如果 B 没收到 ACK 的话，“B 说不玩了”会重发的，A 会重新发一个 ACK 并且足够时间到达 B。

A 直接跑路还有一个问题是，A 的端口就直接空出来了，但是 B 不知道，B 原来发过的很多包很可能还在路上，如果 A 的端口被一个新的应用占用了，这个新的应用会收到上个连接中 B 发过来的包，虽然序列号是重新生成的，但是这里要上一个双保险，防止产生混乱，因而也需要等足够长的时间，等到原来 B 发送的所有的包都死翘翘，再空出端口来。

等待的时间设为 2MSL，**MSL 是 Maximum Segment Lifetime，报文最大生存时间**，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 域，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。协议规定 MSL 为 2 分钟，实际应用中常用的是 30 秒，1 分钟和 2 分钟等。

还有一个异常情况就是，B 超过了 2MSL 的时间，依然没有收到它发的 FIN 的 ACK，怎么办呢？按照 TCP 的原理，B 当然还会重发 FIN，这个时候 A 再收到这个包之后，A 就表示，我已经在这里等了这么长时间了，已经仁至义尽了，之后的我就都不认了，于是就直接发送 RST，B 就知道 A 早就跑了。

### 为什么时间是两个 MSL？

- 1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端
- 1 个 MSL 确保对端没有收到 ACK 时，重传的 FIN 报文可以到达，避免因为无法重传 ACK，被动关闭方因此不能及时可靠释放。

### 挥手可以变为三次吗？

![](images/tcp/wave-four-three.jpg)

是可以的，因为有**延迟确认**的存在，第二步的 ACK 经常会跟随第三步的 FIN 包一起捎带回客户端。

## 重传机制

### ACK 是表示这之前的包都已经全部收到

如果发送 5000 个字节的数据包，因为 MSS 的限制每次传输 1000 个字节，分 5 段传输：

![](images/tcp/ack-retransmission.jpg)

1. 数据包 1 发送的数据正常到达接收端，接收端回复 ACK 1001，表示 seq 为 1001 之前的数据包都已经收到，下次从 1001 开始发。
2. 数据包 2（1001:2001）因为某些原因未能到达服务端，其他包正常到达，这时接收端也不能 ack 3、4、5 数据包，因为数据包 2 还没收到，接收端只能回复 ack 1001。
3. 第 2 个数据包重传成功以后服务器会回复 5001，表示 seq 为 5001 之前的数据包都已经收到了。

### 超时重传

**超时重试**，也即对每一个发送了，但是没有 ACK 的包，都有设一个定时器，超过了一定的时间，就重新尝试。但是这个超时的时间如何评估呢？**这个时间不宜过短，时间必须大于往返时间 RTT**，否则会引起不必要的重传。**也不宜过长，这样超时时间变长，访问就变慢了**。

#### 如何估计往返时间

估计往返时间，需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个值，而且这个值还是要不断变化的，因为网络状况不断的变化。除了采样 RTT，还要采样 RTT 的波动范围，计算出一个估计的超时时间。由于重传时间是不断变化的，我们称为**自适应重传算法（Adaptive RetransmissionAlgorithm）**。

如果数据包 2 丢了，**重传之后又丢了，TCP 的策略是超时间隔加倍。每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送**。

### 快速重传与 SACK

超时触发重传存在的问题是，超时周期可能相对较长。有一个可以快速重传的机制，当接收方收到一个序号大于下一个所期望的报文段时，就检测到了数据流中的一个间格，于是发送三个冗余的 ACK，客户端收到 3 个或以上重复 ACK，就在定时器过期之前，重传丢失的报文段。

例如，接收方发现数据包 3、4、5 都已经接收了，就是 2 没来，那肯定是丢了，于是发送三个 1001 的 ACK，要求下一个是 2。客户端收到 3 个 1001 ACK，就会发现 2 的确丢了，不等超时，马上重发。

#### SACK

有一个问题，发送 3、4、5 包收到的全部是 `ACK=1001`，快速重传解决了一个问题: 需要重传。因为除了 2 号包，3、4、5 包也有可能丢失，那到底是只重传数据包 2 还是重传 2、3、4、5 所有包？

解决办法就是在 TCP 头里加一个 SACK 的东西，可以将缓存的地图发送给发送方，例如：

- 收到 3 号包的时候在 ACK 包中告诉发送端：我目前收到的最大连续的包序号是 1000（ACK=1001），[1:1001]、[2001:3001] 区间的包我也收到了
- 收到 4 号包的时候在 ACK 包中告诉发送端：我目前收到的最大连续的包序号是 1000（ACK=1001），[1:1001]、[2001:4001] 区间的包我也收到了
- 收到 5 号包的时候在 ACK 包中告诉发送端：我目前收到的最大连续的包序号是 1000（ACK=1001），[1:1001]、[2001:5001] 区间的包我也收到了

这样发送端就清楚知道只用重传 2 号数据包就可以了，数据包 3、4、5已经确认无误被对端收到。这种方式被称为 **SACK（Selective Acknowledgment）**。

![](images/tcp/sack.jpg)

## 流量控制

TCP 会把要发送的数据放入发送缓冲区（Send Buffer)，接收到的数据放入接收缓冲区（Receive Buffer），应用程序会不停的读取接收缓冲区的内容进行处理。

流量控制做的事情就是，如果接收缓冲区已满，发送端应该停止发送数据。那发送端怎么知道接收端缓冲区是否已满呢？

为了控制发送端的速率，TCP 在收到数据包回复的 ACK 包里会带上自己接收窗口的大小，接收端需要根据这个值调整自己的发送策略。

### 发送窗口和接收窗口

![](images/tcp/wireshark-win.jpg)

wireshark 抓包中显示的 win=29312 指的就是**接收窗口**的大小。对方收到以后，会把自己的**发送窗口**限制在 29312 大小之内。如果接收端处理能力有限，导致自己的接收缓冲区满，接收窗口大小为 0，发送端应该停止发送数据。

- **接收窗口（rwnd）是接收端的限制，是接收端还能接收的数据量大小**
- **拥塞窗口（cwnd）是发送端的限制，是发送端在还未收到对端 ACK 之前还能发送的数据量大小**

#### 发送窗口

![](images/tcp/aw.jpg)

发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分：

- 红色部分：发送了并且已经确认的。这部分就是你交代下属的，并且也做完了的，应该划掉的。
- 蓝色部分：发送了并且尚未确认的。这部分是你交代下属的，但是还没做完的，需要等待做完的回复之后，才能划掉。
- 绿色部分：没有发送，但是已经等待发送的。这部分是你还没有交代给下属，但是马上就要交代的。
- 黄色部分：没有发送，并且暂时还不会发送的。这部分是你还没有交代给下属，而且暂时还不会交代给下属的。

发送窗口的大小就是蓝色部分加上绿色部分。

可用窗口是发送端还能发送的最大数据包大小，就是绿色部分。

窗口的**左边界**表示成功发送并已经被接收方确认的最大字节序号，窗口的**右边界**是发送方当前可以发送的最大字节序号，滑动窗口的大小等于
右边界减去左边界。

当上图中的可用区域的 6 个字节（46~51）发送出去，可用窗口区域减小到 0，这个时候除非收到接收端的 ACK 数据，否则发送端将不能发送数据。
如果使用 wireshark 抓包，可以看到 TCP Window Full，表示**包的发送方已经把对方所声明的接收窗口耗尽了**。
![](images/tcp/aw2.jpg)

#### TCP Zero Window

TCP zero window 是站在**接收端**角度来说的，TCP 包中 `win=` 表示接收窗口的大小，表示接收端还有多少缓冲区可以接收数据，当窗
口变成 0 时，表示接收端不能暂时不能再接收数据了。

![](images/tcp/recvbuffer.jpg)

一开始三次握手确定接收窗口大小为 360 字节。

1. 发送端发送 140 字节给接收端，此时因为 140 字节在途未确认，所以它的可用滑动窗口大小为：360 - 140 = 220
2. 接收端收到 140 字节以后，将这 140 字节放入TCP 接收区缓冲队列。正常情况下，接收端处理的速度非常快，这 140 字节会马上被应
用层取走并释放这部分缓冲区，同时发送确认包给发送端，这样接收端的窗口大小（RCV.WND)马上可以恢复到 360 字节，发送端收到确认包以
后也马上将可用发送滑动窗口恢复到 360 字节。但是如果因为高负载等原因，导致 TCP 没有立马处理接收到的数据包，收到的 140 字节没能全
部被取走，这个时候 TCP 会在返回的 ACK 里携带它建议的接收窗口大小，因为自己的处理能力有限，那就告诉对方下次发少一点数据。假设如上
图的场景，收到了 140 字节数据，现在只能从缓冲区队列取走 40 字节，还剩下 100 字节留在缓冲队列中，接收端将接收窗口从
原来的 360 减小 100 变为 260。
3. 发送端接收到 ACK 以后，根据接收端的指示，将自己的发送滑动窗口减小到 260。所有的数据都已经被确认，这时候可用窗口大小
也等于 260
4. 发送端继续发送 180 字节的数据给接收端，可用窗口= 260 - 180 = 80。
5. 接收端收到 180 字节的数据，因为负载高等原因，没有能取走数据，将接收窗口再降低 180，变为 80，在回复给对端的 ACK 里携带回去。
6. 发送端收到 ACK 以后，将自己的发送窗口减小到 80，同时可用窗口也变为 80
7. 发送端继续发送 80 字节数据给接收端，在未确认之前在途字节数为 80，发送端可用窗口变为 0
8. 接收端收到 80 字节的数据，放入接收区缓冲队列，但是入之前原因，没能取走，滑动窗口进一步减小到 0，在回复的 ACK 里捎带回去
9. 发送端收到 ACK，根据发送端的指示，将自己的滑动窗口总大小减小为 0

##### 零窗口探测包

现在发送端的滑动窗口变为 0 了，如果这样的话，发送方会定时发送窗口探测数据包，看是否有机会调整窗口的大小。当接收方比较慢的时
候，**要防止低能窗口综合征，别空出一个字节来就赶快告诉发送方，然后马上又填满了，可以当窗口太小的时候，不更新窗口，直到达到一定大
小，或者缓冲区一半为空，才更新窗口**。

## 拥塞控制问题

拥塞控制的问题，也是通过窗口的大小来控制的，前面的**滑动窗口 rwnd 是怕发送方把接收方缓存塞满，而拥塞窗口 cwnd，是怕把网络塞满**。

拥塞窗口初始值等于操作系统的一个变量 `initcwnd`，最新的 linux 系统 `initcwnd` 默认值等于 10。

**真正的发送窗口大小** = **接收端接收窗口大小** 与 **发送端自己拥塞窗口大小两者的最小值**。

如果接收窗口比拥塞窗口小，表示接收端处理能力不够。如果拥塞窗口小于接收窗口，表示接收端处理能力 ok，但网络拥塞。

发送端和接收端不会交换 cwnd 这个值，这个值是维护在发送端本地内存中的一个值。

**TCP 的拥塞控制就是在不堵塞，不丢包的情况下，尽量发挥带宽**。

### 慢启动

TCP 的拥塞控制主要来避免两种现象，包丢失和超时重传。一旦出现了这些现象就说明，发送速度太快了，要慢一点。但是一开始我怎么知道速度多快
呢，我怎么知道应该把窗口调整到多大呢？

每个 TCP 连接都有一个拥塞窗口的限制，最初这个值很小，随着时间的推移，每次发送的数据量如果在不丢包的情况下，“慢慢”的递增，这种机
制被称为**慢启动**。

拥塞控制是从整个网络的大局观来思考的，如果没有拥塞控制，某一时刻网络的时延增加、丢包频繁，发送端疯狂重传，会造成网络更重的负担，而更
重的负担会造成更多的时延和丢包，形成雪崩的网络风暴。

这个算法的过程如下：

1. 三次握手以后，双方通过 ACK 告诉了对方自己的接收窗口（rwnd）的大小，之后就可以互相发数据了
2. 通信双方各自初始化自己的「拥塞窗口」（Congestion Window，cwnd）大小。
3. cwnd 初始值较小时，每收到一个 ACK，cwnd + 1，每经过一个 RTT，cwnd 变为之前的两倍。

假设 RTT 为 50ms，客户端和服务端的接收窗口为 65535 字节（64KB），初始拥塞窗口为：10 段（MSS），那么要达到 64KB 的吞吐量，
拥塞窗口的段数 = 65535 / 1460 = 45 段，需要的 RTT 次数 = log2（45 / 10）= 2.12 次，需要的时间 = 50 * 2.12 = 106ms。
也就是客户端和服务器之间的 64KB 的吞吐量，需要 2.12 次 RTT，100ms 左右的延迟。

### 慢启动阈值

慢启动拥塞窗口（cwnd）肯定不能无止境的指数级增长下去，否则拥塞控制就变成了拥塞失控了，它的阈值
称为**慢启动阈值**（Slow Start Threshold，ssthresh）

- 当 cwnd < ssthresh 时，拥塞窗口按指数级增长（慢启动）
- 当 cwnd > ssthresh 时，拥塞窗口按线性增长（拥塞避免）

### 拥塞避免

当 cwnd > ssthresh 时，拥塞窗口进入**拥塞避免**（Congestion Avoidance）阶段。

每收到一个确认后，cwnd 增加 1/cwnd，我们接着上面的过程来，一次发送八个，当八个确认到来的时候，每个确认增加 1/8，八个确认一共 cwnd 增
加 1，于是一次能够发送九个，变成了线性增长。但是线性增长还是增长，还是越来越多，直到有一天，水满则溢，出现了拥塞，这时候一般就会一下子
降低倒水的速度，等待溢出的水慢慢渗下去。拥塞的一种表现形式是丢包，需要超时重传，这个时候，将 sshresh 设为 cwnd/2，将 cwnd 设为 1，重
新开始慢启动。这真是一旦超时重传，马上回到解放前。但是这种方式太激进了，将一个高速的传输速度一下子停了下来，会造成网络卡顿。

当接收端发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速的重传，不必等待超时再重传。TCP 认为这种情况不严重，因为大部
分没丢，只丢了一小部分，cwnd 减半为 cwnd/2，然后 sshthresh = cwnd，当三个包返回的时候，cwnd = sshthresh +3，也就是没有一夜回到
解放前，而是还在比较高的值，呈线性增长。就像前面说的一样，正是这种知进退，使得时延很重要的情况下，反而降低了速度。但是如果你仔细想一下，
TCP 的拥塞控制主要来避免的两个现象都是有问题的。

- 第一个问题是丢包并不代表着通道满了，也可能是管子本来就漏水。例如公网上带宽不满也会丢包，这个时候就认为拥塞了，退缩了，其实是不对的。
- 第二个问题是 TCP 的拥塞控制要等到将中间设备都填充满了，才发生丢包，从而降低速度，这时候已经晚了。其实 TCP 只要填满管道就可以了，不应
该接着填，直到连缓存也填满。

为了优化这两个问题，后来有了 TCP BBR 拥塞算法。它企图找到一个平衡点，就是通过不断的加快发送速度，将管道填满，但是不要填满中间设备的缓
存，因为这样时延会增加，在这个平衡点可以很好的达到高带宽和低时延的平衡。

## 延迟确认

- 不是每个数据包都对应一个 ACK 包，因为可以合并确认。
- 也不是接收端收到数据以后必须立刻马上回复确认包。

如果收到一个数据包以后暂时没有数据要分给对端，它可以等一段时间（Linux 上是 40ms）再确认。如果这段时间刚好有数据要传给对端，ACK 就可
以随着数据一起发出去了。如果超过时间还没有数据要发送，也发送 ACK，以免对端以为丢包了。这种方式称为**延迟确认**。

可需要立即回复 ACK 的场景有：

- 如果接收到了大于一个 frame 的报文，且需要调整窗口大小
- 处于 quickack 模式（tcp_in_quickack_mode）
- 收到乱序包（We have out of order data.）

其它情况一律使用延迟确认的方式。

Linux 上并没有开关可以关闭延迟确认。

## 定时器

TCP 为每条连接建立了 7 个定时器：

- 连接建立定时器，当发送端发送 SYN 报文想建立一条新连接时，会开启连接建立定时器，如果没有收到对端的 ACK 包将进行重传。
- 重传定时器
- 延迟 ACK 定时器，在 TCP 收到数据包以后在没有数据包要回复时，不马上回复 ACK。这时开启一个定时器，等待一段时间看是否有数据需要回复。
- PERSIST 定时器，为零窗口探测而准备的。当接收端 B 接收窗口为 0 时，发送端 A 此时不能再发送数据，发送端此时开启 Persist 定时器。
- KEEPALIVE 定时器
- FIN_WAIT_2 定时器，主动关闭的一方收到 ACK 以后从 FIN_WAIT_1 进入 FIN_WAIT_2 状态等待对端的 FIN 包的到来，FIN_WAIT_2 定时器
的作用是防止对方一直不发送 FIN 包，防止自己一直傻等。
- TIME_WAIT 定时器，也称为 2MSL 定时器，主动关闭连接的一方在 TIME_WAIT 持续 2 个 MSL 的时间，超时后端口号可被安全的重用。



## TCP 状态机

![](images/tcp/tcp-status.jpg)

### CLOSED

这个状态是一个**假想**的状态，是 TCP 连接还未开始建立连接或者连接已经彻底释放的状态。

从 CLOSE 状态转换为其它状态有两种可能：

- 主动打开（Active Open），客户端主动发送一个 SYN 包准备三次握手，被称为**主动打开（Active Open）**
- 被动打开（Passive Open），服务端会监听一个特定的端口，等待客户端的新连接，同时会进入 LISTEN 状态，称为**被动打开**

### LISTEN

通常是服务端调用 bind、listen 系统调用监听特定端口时进入到LISTEN状态，等待客户端发送 SYN 报文三次握手建立连接。

### SYN-SENT

客户端发送 SYN 报文等待 ACK 的过程进入 SYN-SENT状态。同时会开启一个定时器，如果超时还没有收到 ACK 会重发 SYN。

### SYN-RCVD

服务端收到 SYN 报文以后会回复 SYN+ACK，然后进入 SYN-RCVD 状态，等待对端 ACK。

### ESTABLISHED

SYN-SENT 或者 SYN-RCVD 状态的连接收到对端确认 ACK 以后进入 ESTABLISHED 状态，连接建立成功。

### FIN-WAIT-1

主动关闭的一方发送了 FIN 包，等待对端回复 ACK 时进入 FIN-WAIT-1 状态。

### FIN-WAIT-2

处于 FIN-WAIT-1 状态的连接收到 ACK 确认包以后进入 FIN-WAIT-2 状态，这个时候主动关闭方的 FIN 包已经被对方确认，等待被
动关闭方发送 FIN 包。

### CLOSE-WAIT

当有一方想关闭连接的时候，发送 FIN 包给对端，这个被动关闭方，收到 FIN 包以后进入 CLOSE-WAIT 状态。

### TIME-WAIT

TIME-WAIT 是收到了被动关闭方的 FIN 包，发送确认 ACK 给对端，开启 2MSL 定时器，定时器到期时进入 CLOSED 状态，连接释放。

### LAST-ACK

LAST-ACK 顾名思义等待最后的 ACK。是被动关闭的一方，发送 FIN 包给对端等待 ACK 确认时的状态。
当收到 ACK 以后，进入 CLOSED 状态，连接释放。

### CLOSING

CLOSING状态在**同时关闭**情况下出现。这里的同时其实并不是时间意义上的同时，而是指的是在发送 FIN 包还未收到确认之前，
收到了对端的 FIN 的情况。

![](images/tcp/both-off.jpg)

1. 最初客户端和服务端都处于 ESTABLISHED 状态
2. 客户端发送 FIN 包，等待对端对这个 FIN 包的 ACK，随后进入 FIN-WAIT-1 状态
3. 处于 FIN-WAIT-1 状态的客户端还没有等到 ACK，收到了服务端发过来的 FIN 包
4. 收到 FIN 包以后客户端会发送对这个 FIN 包的的确认 ACK 包，同时自己进入 CLOSING 状态，继续等自己 FIN 包的 ACK
5. 处于 CLOSING 状态的客户端终于等到了 ACK，随后进入 TIME-WAIT
6. 在 TIME-WAIT 状态持续 2*MSL，进入 CLOSED 状态


## 总结
1、超时重传
a、TCP重传定时器:
TCP使用重传定时器来检测数据包的丢失。当TCP发送一个数据包后，它会启动一个定时器。如果在这个定时器超时之前，TCP没有收到该数据包的确认（ACK），则TCP会假定该数据包已经丢失，并重传该数据包。
b、指数退避算法：
TCP在重传数据包时，会采用一种称为“指数退避”的算法来调整重传时间间隔。这意味着每次重传失败后，TCP会将重传时间间隔加倍（或按指数增加），以减少网络拥塞的可能性。
c、tcp_retries2 参数：
在Linux系统中，/proc/sys/net/ipv4/tcp_retries2 参数定义了TCP在放弃连接之前尝试重传数据包的次数（在TIME_WAIT状态之后）。这个值默认通常为15，需要注意的是，tcp_retries2 控制的是进入TIME_WAIT状态后的重传次数，而不是整个连接过程中的重传次数。
2、快速重传机制与 SACK
a、快速重传的含义是：当发送端收到 3 个或以上重复 ACK，就意识到之前发的包可能丢了，于是马上进行重传，不用傻傻的等到超时再重传。
b、为了避免每次重传都从缺失的seq开始，如本文中数据包2，而反复传后续所有包，可以接收方采用 SACK（Selective Acknowledgment）来告知发送方，即在 接收方回复的ACK 包的 option 选项里，包含了 SACK 的信息。这样发送方只用重传 2 号数据包就可以了，数据包 3、4、5已经确认无误被接收方收到。


接收窗口（rwnd）是接收端的限制，是接收端还能接收的数据量大小
拥塞窗口（cwnd）是发送端的限制，是发送端在还未收到对端 ACK 之前还能发送的数据量大小，为了避免网络拥塞主动控制不要发送过多的数据

发送端和接收端不会交换 cwnd 这个值，这个值是维护在发送端本地内存中的一个值

当 cwnd < ssthresh 时，拥塞窗口按指数级增长（慢启动）
当 cwnd > ssthresh 时，拥塞窗口按线性增长（拥塞避免）

当 cwnd > ssthresh 时，拥塞窗口进入「拥塞避免」阶段，在这个阶段，每一个往返 RTT，拥塞窗口大约**增加 1 个 MSS 大小**，直到检测到拥塞为止。

慢启动的做法是 RTT 时间内每收到一个 ACK，拥塞窗口 cwnd 就加 1，也就是每经过 1 个 RTT，cwnd 翻倍
拥塞避免的做法保守的多，每经过一个RTT 才将拥塞窗口加 1，不管期间收到多少个 ACK

当收到三次重复 ACK 时，进入快速恢复阶段。解释为网络轻度拥塞。

拥塞阈值 ssthresh 降低为 cwnd 的一半：ssthresh = cwnd / 2
拥塞窗口 cwnd 设置为 ssthresh
拥塞窗口线性增加




1、为什么有的流量控制，还需要拥塞控制？
流控只简单地表明了接收方的处理能力，并不能代表中间网络的处理能力，因此需要拥塞控制避免中间路由器处理不过来，导致数据丢失。
2、拥塞控制的几种算法？
3、慢启动应该在传输之初就启动，这一点一定要明确。
4、慢启动、快速恢复中的快慢指的是数学上概念，慢启动指的是cwnd呈指数增长，斜率越来越大；快速恢复是指当收到三次重复 ACK后，cwnd被强制减少到一个极低的值，然后快速恢复到最合适的cwnd区间。