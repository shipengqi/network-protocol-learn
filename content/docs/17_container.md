---
title: 容器网络
weight: 17
---

如果说虚拟机是买公寓，容器则相当于合租，有一定的隔离，但是隔离性没有那么好。

云计算解决了基础资源层的弹性伸缩，却没有解决PaaS层应用随基础资源层弹性伸缩而带来的批量、快速部署问题。于是，容器应运而生。

**容器的思想就是要变成软件交付的集装箱**。集装箱的特点，**一是打包，二是标准**。比如在把货从一个码头运到另一个码头，使用集装箱把货物打包，就可以一整箱搬上船，在整箱搬到另一个码头。如果没有
集装箱，就要先一件件搬上船码好，在一件件搬到另一个码头。

## 容器如何对应用打包

容器实现隔离主要用了两种技术，一种是**看起来是隔离的技术**，称为**namespace**，即每个namespace中的应用看到的是不同的IP地址、用户空间、程号等。
一种是**用起来是隔离的技术**，称为**cgroup**，也即明明整台机器有很多的CPU、内存，而一个应用只能用其中的一部分。

所谓镜像，就是将你焊好集装箱的那一刻，将集装箱的状态保存下来，然后将这一刻的状态保存成一系列文件。无论从哪里运行这个镜像，都能完整地还原当时的情况。

## namespace

在Linux下很多的资源都是全局的。比如进程有全局的进程ID，网络也有全局的路由表。但是，当一台Linux上跑多个进程的时候，如果我们觉得使用不同的路由策略，这些进程可能会冲突，
那就需要将这个进程放在一个独立的namespace里面，这样就可以独立配置网络了

## cgroup

cgroup全称control groups，是Linux内核提供的一种可以限制、隔离进程使用的资源机制。

cgroup能控制哪些资源呢？它有很多子系统：

- CPU子系统使用调度程序为进程控制CPU的访问
- cpuset，如果是多核心的CPU，这个子系统会为进程分配单独的CPU和内存
- memory子系统，设置进程的内存限制以及产生内存资源报告
- blkio子系统，设置限制每个块设备的输入输出控制
- net_cls，这个子系统使用等级识别符（classid）标记网络数据包，可允许Linux 流量控制程序（tc）识别从具体cgroup中生成的数据包

cgroup提供了一个虚拟文件系统，作为进行分组管理和各子系统设置的用户接口。要使用cgroup，必须挂载cgroup文件系统，一般情况下都是挂载到`/sys/fs/cgroup`目录下。

## 容器网络中如何融入物理网络

如果你使用docker run运行一个容器，你应该能看到这样一个拓扑结构。
![](/images/network-protocol/dockernet.jpg)

是不是和虚拟机很像？容器里面有张网卡，容器外有张网卡，容器外的网卡连到docker0网桥，通过这个网桥，容器直接实现相互访问。如果你用brctl查看docker0网桥，你会发现它上面连着一些网卡。
其实这个网桥和用brctl创建的网桥没什么两样。

那连接容器和网桥的那个网卡和虚拟机一样吗？在虚拟机场景下，有一个虚拟化软件，通过TUN/TAP设备虚拟一个网卡给虚拟机，但是容器场景下并没有虚拟化软件，这该怎么办呢？在Linux下，
可以创建一对**veth pair**的网卡，从一边发送包，另一边就能收到。

一台机器内部容器的如何访问外网？
就是虚拟机里面的桥接模式和NAT模式。Docker默认使用NAT模式。NAT模式分为SNAT和DNAT，如果是容器内部访问外部，就需要通过SNAT。
在宿主机上，有这么一条iptables规则：

```bash
-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE
```

所有从容器内部发出来的包，都要做地址伪装，将源IP地址，转换为物理网卡的IP地址。如果有多个容器，所有的容器共享一个外网的IP地址，但是在conntrack表中，记录下这个出去的连接。当服务器返回结果的时候，
到达物理机，会根据conntrack表中的规则，取出原来的私网IP，通过DNAT将地址转换为私网IP地址，通过网桥docker0实现对内的访问。

Docker有两种方式，一种是通过一个进程**docker-proxy**的方式，监听10080，转换为80端口。

```bash
/usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 10080 -container-ip 172.17.0.2 -container-port 80
```

另外一种方式是通过DNAT方式，在-A PREROUTING阶段加一个规则，将到端口10080的DNAT称为容器的私有网络。

```bash
-A DOCKER -p tcp -m tcp --dport 10080 -j DNAT --to-destination 172.17.0.2:80
```

## 容器网络之Flannel：每人一亩三分地

容器作为集装箱，可以保证应用在不同的环境中快速迁移，提高迭代的效率。但是如果要形成容器集团军，还需要一个集团军作战的调度平台，这就是Kubernetes。它可以灵活地将一个容器调度到任何一台机器上，并且当某个应
用扛不住的时候，只要在Kubernetes上修改容器的副本数，一个应用马上就能变八个，而且都能提供服务。

集团军作战有个重要的问题，就是通信。这里面包含两个问题，第一个是集团军的A部队如何实时地知道B部队的位置变化，第二个是两个部队之间如何相互通信。

第一个问题**位置变化，往往是通过一个称为注册中心的地方统一管理的。这个是应用自己做的。当一个应用启动的时候，将自己所在环境的IP地址和端口，注册到注册中心指挥部，这样其他的应用请求它的时候，
到指挥部问一下它在哪里就好了**。

接下来是如何相互通信的问题。NAT这种模式，在多个主机的场景下，是存在很大问题的。在物理机A上的应用A看到的IP地址是容器A的，是`172.17.0.2`，在物理机B上的应用B看到的IP地址是容器B的，
不巧也是`172.17.0.2`，当它们都注册到注册中心的时候，注册中心就是这个图里这样子。

![](/images/network-protocol/flannel1.jpg)

应用A要访问应用B，当应用A从注册中心将应用B的IP地址读出来的时候，就彻底困惑了，这不是自己访问自己吗？

怎么解决这个问题呢？一种办法是不去注册容器内的IP地址，而是注册所在物理机的IP地址，端口也要是物理机上映射的端口。但是一方面，大部分分布式框架都是容器诞生之前就有了，它们不会适配这种场景；另一方面，
让容器内的应用意识到容器外的环境，本来就是非常不好的设计。

于是业界就涌现了大量的方案，Flannel就是其中之一。
