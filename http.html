<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>Network protocol learning | HTTP </title>
    <meta name="description" content>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/network-protocol-learn/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/network-protocol-learn/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"title":"HTTP","path":"http.html"},"data":{"navigation":{"logo":{"text":"Network Protocol Learn","type":"link","path":"index.html"},"main":[{"text":"IP","type":"link","path":"ip.html"},{"text":"物理层和链路层","type":"link","path":"physical_link.html"},{"text":"ICMP","type":"link","path":"icmp.html"},{"text":"网关","type":"link","path":"gateway.html"},{"text":"UDP","type":"link","path":"udp.html"},{"text":"TCP","type":"link","path":"tcp.html"},{"text":"HTTP","type":"link","path":"http.html"},{"text":"HTTPS","type":"link","path":"https.html"},{"text":"流媒体协议","type":"link","path":"stream.html"},{"text":"P2P 协议","type":"link","path":"p2p.html"},{"text":"DNS","type":"link","path":"dns.html"},{"text":"CDN","type":"link","path":"cdn.html"},{"text":"数据中心","type":"link","path":"data_center.html"},{"text":"VPN","type":"link","path":"vpn.html"},{"text":"移动网络","type":"link","path":"nemo.html"},{"text":"云中网络","type":"link","path":"cloud.html"},{"text":"容器网络","type":"link","path":"container.html"},{"text":"RPC","type":"link","path":"rpc.html"},{"text":"网络工具","type":"label"},{"text":"网络工具","type":"link","path":"net_tools.html"},{"text":"WireShark","type":"link","path":"wireshark.html"},{"text":"THEME","type":"label"},{"text":"使用文档主题","type":"link","path":"theme/theme-usage.html"},{"text":"SUPPORT AND FEEDBACK","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/shipengqi/network-protocol-learn/issues/new"}]}},"config":{"timezone":"UTC","root":"/network-protocol-learn/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot><nav class="doc-navbar"><a href="/network-protocol-learn/index.html" class="doc-navbar__logo"><img src="/network-protocol-learn/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">Network Protocol Learn</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p><code>http://www.163.com</code> 是个URL，叫作<strong>统一资源定位符</strong>。之所以叫统一，是因为它是有格式的。<code>http</code> 表示协议，<code>www.163.com</code> 是一个域名，<br>表示互联网上的一个位置。有的 URL 会有更详细的位置标识，例如 <code>http://www.163.com/index.html</code>。正是因为这个东西是统一的，所以当你把<br>这样一个字符串输入到浏览器的框里的时候，浏览器才知道如何进行统一处理。</p>
<h2 id="HTTP-请求的准备"><a href="#HTTP-请求的准备" class="headerlink" title="HTTP 请求的准备"></a>HTTP 请求的准备</h2><ul>
<li>浏览器会将 <code>www.163.com</code> 这个域名发送给 DNS 服务器，让它解析为 IP 地址。</li>
<li>HTTP 是基于 TCP 协议的，要先建立 TCP 连接，目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 <code>Keep-Alive</code> 的，<br>不需要再声明 <code>Connection: keep-alive</code>。这样建立的 TCP 连接，就可以在多次请求中复用。</li>
</ul>
<h2 id="HTTP-请求的构建"><a href="#HTTP-请求的构建" class="headerlink" title="HTTP 请求的构建"></a>HTTP 请求的构建</h2><p>建立了连接以后，浏览器就要发送HTTP 的请求。</p>
<p><img src="images/http/http-request.jpg" alt></p>
<p>HTTP 的报文的三大部分：</p>
<ul>
<li>请求行，</li>
<li>请求的首部</li>
<li>请求的正文实体。</li>
</ul>
<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>URL 就是 <code>http://www.163.com</code>，版本为 HTTP 1.1。方法有几种类型, <code>get</code>,<code>post</code>,<code>put</code>,<code>delete</code>。</p>
<h3 id="首部字段"><a href="#首部字段" class="headerlink" title="首部字段"></a>首部字段</h3><p><strong>首部是 key value，通过 <code>:</code> 分隔</strong>。重点<strong>缓存</strong>，为啥要使用缓存？因为一个非常大的页面有很多东西。</p>
<p>例如，我浏览一个商品的详情，里面有这个商品的价格、库存、展示图片、使用手册等等。展示图片会保持较长时间不变，而库存会根据用户购买的<br>情况经常改变。如果图片非常大，而库存数非常小，如果我们每次要更新数据的时候都要刷新整个页面，对于服务器的压力就会很大。</p>
<p>对于这种高并发场景下的系统，在真正的业务逻辑之前，都需要有个接入层，将这些静态资源的请求拦在最外面。</p>
<p><img src="images/http/arch.jpg" alt></p>
<p>和这一节关系比较大的就是 Nginx 这一层，它如何处理 HTTP 协议？对于静态资源，有 Vanish 缓存层。当缓存过期的时候，才会访问真正<br>的 Tomcat 应用集群。</p>
<p>在 HTTP 头里面，<code>Cache-control</code> 是用来<strong>控制缓存</strong>的。</p>
<h2 id="HTTP-请求的发送"><a href="#HTTP-请求的发送" class="headerlink" title="HTTP 请求的发送"></a>HTTP 请求的发送</h2><p>HTTP 协议是基于 TCP 协议的，所以它使用面向连接的方式发送请求，通过 stream 二进制流的方式传给对方。当然，到了 TCP 层，它会把二进制流<br>变成一个的报文段发送给服务器。</p>
<p>IP 层 -&gt; ARP 获取 MAC -&gt; 路由器 -&gt; 找到机器 -&gt; 解析 MAC IP TCP 根据端口号 -&gt; 找到 HTTP 服务，</p>
<h2 id="HTTP-返回的构建"><a href="#HTTP-返回的构建" class="headerlink" title="HTTP 返回的构建"></a>HTTP 返回的构建</h2><p><img src="images/http/http-response.jpg" alt></p>
<p>返回报文的三大部分：</p>
<ul>
<li>状态行，</li>
<li>首部</li>
<li>实体。</li>
</ul>
<p>状态码会反应 HTTP 请求的结果。</p>
<p><strong>首部是 key value，通过冒号分隔</strong>。</p>
<h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h3><p>HTTP 1.1 在应用层以纯文本的形式进行通信。每次通信都要带完整的 HTTP 的头，而且不考虑 pipeline 模式的话，每次的过程总是像上面描述的那<br>样一去一回。这样在实时性、并发性上都存在问题。</p>
<p>为了解决这些问题，HTTP 2.0 会对 HTTP 的头进行一定的压缩，将原来每次都要携带的大量 key value 在两端建立一个索引表，对相同的头只发<br>送索引表中的索引。</p>
<p>HTTP 2.0 协议将一个 TCP 的连接中，切分成多个流，每个流都有自己的 ID，而且流可以是客户端发往服务端，也可以是服务端发往客户端。它其实<br>只是一个虚拟的通道。流是有优先级的。</p>
<p>HTTP 2.0 还将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码。常见的帧有 Header 帧，用于传输 Header 内容，并且会开启<br>一个新的流。再就是 Data 帧，用来传输正文实体。多个 Data 帧属于同一个流。</p>
<p>通过这两种机制，HTTP 2.0 的客户端可以将多个请求分到不同的流中，然后将请求内容拆成帧，进行二进制传输。这些帧可以打散乱序发送，然后根据<br>每个帧首部的流标识符重新组装，并且可以根据优先级，决定优先处理哪个流的数据。</p>
<p>举一个例子：</p>
<p>假设我们的一个页面要发送三个独立的请求，一个获取 css，一个获取 js，一个获取图片 jpg。如果使用 HTTP 1.1 就是串行的，但是如果使<br>用 HTTP 2.0，就可以在一个连接里，客户端和服务端都可以同时发送多个请求或回应，而且不用按照顺序一对一对应。</p>
<p><img src="images/http/http2stream1.jpg" alt></p>
<p>HTTP 2.0 其实是将三个请求变成三个流，将数据分成帧，乱序发送到一个 TCP 连接中。</p>
<p><img src="images/http/http2stream2.jpg" alt></p>
<p>HTTP 2.0 成功解决了 HTTP 1.1 的队首阻塞问题，同时，也不需要通过 HTTP 1.x 的 pipeline 机制用多条 TCP 连接来实现并行请求与响应；<br>减少了 TCP 连接数对服务器性能的影响，同时将页面的多个数据 css、js、jpg 等通过一个数据链接进行传输，能够加快页面组件的传输速度。</p>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/network-protocol-learn/script/doc.js"></script>

    

  </body>
</html>
